[{"title":"mipi_csi_imx415","date":"2025-04-15T02:23:17.326Z","path":"2025/04/15/mipi_csi_imx415/","text":"泰山派移植IMX415摄像头CMOS摄像头整体的数据流向 image-20250311140607067 IMX415驱动代码框架","tags":[]},{"title":"INAV_NxtPx4","date":"2025-04-14T17:12:21.000Z","path":"2025/04/14/INAV_NxtPX4/","text":"INAV_NxtPx4为基于STM32H743VIH6主控的新飞控板适配INAV固件，需要结合硬件设计与INAV固件的开发框架进行定制化配置。以下是适配的核心步骤及注意事项： 一、开发环境搭建 获取INAV源码从GitHub克隆INAV仓库，切换到支持H7系列的最新分支（如INAV 8.0及以上版本）。 1git clone https://github.com/INAVFlight/inav.git 配置工具链安装ARM GCC编译工具链（如gcc-arm-none-eabi），并确保CMake版本兼容。H743需支持STM32H7系列的编译配置。 二、硬件描述文件配置INAV通过target目录下的硬件描述文件定义飞控板的资源分配，需基于现有类似型号（如MATEKF405或官方支持的H743型号）进行修改： 创建新目标目录在src/main/target下新建目录（如CUSTOM_H743），复制相近型号的配置文件（如target.h、target.c、CMakeLists.txt）。 主控芯片定义在CMakeLists.txt中指定主控型号，例如： 1target_stm32h743xx(CUSTOM_H743) 引脚与外设映射 LED与蜂鸣器：定义状态指示灯和蜂鸣器引脚。 12#define LED0 PC13#define BEEPER PB8 SPI&#x2F;I2C总线：配置传感器接口。例如双IMU（如BMI270、ICM-42688）需指定SPI总线及片选引脚： 123#define USE_SPI_DEVICE_1#define SPI1_SCK_PIN PA5#define BMI270_CS_PIN PC2 UART接口：映射串口功能（GPS、接收机、图传等）。例如： 12#define USE_UART3#define UART3_RX_PIN PC11 // GPS接口 传感器配置 陀螺仪与加速度计：启用并指定型号及校准方向（如IMU_BMI270_ALIGN CW0_DEG）。 气压计与磁力计：若使用DPS310或IST8310，需启用对应驱动并指定I2C总线。 OSD与TF卡：配置AT7456E OSD芯片及SD卡接口（若支持）。 三、固件编译与烧录 编译命令使用CMake生成编译配置，指定目标名称： 1make CUSTOM_H743 烧录固件 DFU模式：按住BOOT按钮连接USB，使用地面站（如INAV Configurator）或dfu-util工具烧录。 SWD调试：通过ST-Link或J-Link直接烧录（需配置USE_SWD）。 四、地面站调试与验证 连接与初始化使用INAV Configurator连接飞控，检查传感器数据（陀螺仪、加速度计、气压计）是否正常显示。 功能配置 接收机协议：在CLI中设置serialrx_provider（如SBUS、CRSF）。 电机输出：配置PWM&#x2F;DShot协议及电机映射顺序。 OSD叠加：启用并调整显示内容（如电压、飞行模式）。 校准与测试 传感器校准：执行加速度计、陀螺仪、磁力计校准。 电机测试：通过地面站逐步测试各电机响应，确保无冲突。 五、常见问题与优化 驱动缺失若电脑无法识别飞控，需安装STM32 VCP驱动（如stm32cubeprog包含的驱动）。 硬件冲突 电源干扰：确保传感器（如IMU）独立供电以减少噪声。 引脚复用：避免UART与SPI&#x2F;I2C引脚冲突（参考芯片数据手册）。 性能优化 DMA配置：为高频外设（如陀螺仪SPI）启用DMA以降低CPU负载。 时钟分配：优化STM32H7的时钟树，确保外设时钟与主频匹配。 参考案例 MicoAir743飞控：支持INAV 8.0+，其硬件描述文件可直接参考（如UART映射、传感器配置）。 星火计划H743飞控：采用双IMU设计，需在target.h中分别定义两个陀螺仪的SPI总线及校准参数。 通过以上步骤，结合硬件特性调整配置文件，即可完成INAV对STM32H743VIH6飞控板的适配。开发过程中建议参考官方文档及社区案例以解决具体问题。","tags":[{"name":"硬件,四轴","slug":"硬件-四轴","permalink":"https://dailynobug.github.io/tags/%E7%A1%AC%E4%BB%B6-%E5%9B%9B%E8%BD%B4/"}]},{"title":"ELRS_RX&TX","date":"2025-04-13T09:17:51.000Z","path":"2025/04/13/ELRS_RX&TX/","text":"ELRS信号收发ELRS介绍ExpressLRS（简称 ELRS）是一个开源的、高性能的无线电控制（RC）链路系统。它主要用于遥控模型（如无人机、固定翼飞机、遥控车等），旨在提供长距离、低延迟、高刷新率和高抗干扰性的无线连接。 核心特点： 开源: 固件代码完全开放，由社区驱动开发和维护。 高性能: 相较于许多传统 RC 协议，ELRS 提供更低的延迟（可达毫秒级）和更高的数据包刷新率（可达 1000Hz）。 远距离: 基于 Semtech 的 LoRa（远距离）物理层调制技术（以及 2.4GHz 上的 FLRC），即使在较低功率下也能实现数公里甚至数十公里的控制距离。 高抗干扰: 结合了 LoRa&#x2F;FLRC 调制和跳频技术（FHSS），在复杂的无线环境中具有更好的鲁棒性。 成本效益: 通常基于 ESP32、ESP8285 或 STM32 等低成本微控制器和 Semtech SX127x (868&#x2F;915MHz) 或 SX128x (2.4GHz) 射频芯片构建。 丰富功能: 支持完整的遥测回传、动态发射功率调整、无线固件更新等。 ELRS 实现原理ELRS 的实现依赖于硬件（射频芯片+MCU）和软件（ELRS 固件）的结合。其核心原理可以概括为以下几点： 物理层调制 (PHY): 主要使用 LoRa 调制：这是一种扩频调制技术，通过牺牲一部分数据传输速率来换取极高的接收灵敏度（意味着可以接收到非常微弱的信号）和抗干扰能力，从而实现远距离通信。 在 2.4GHz 频段，ELRS 也支持 FLRC (Fast Long Range Communication) 调制，它能在保持较好距离和抗干扰性的同时，提供比 LoRa 更高的数据速率和更低的延迟。固件会根据配置（如数据包速率）智能选择使用 LoRa 还是 FLRC。 数据链路层: 定制协议: ELRS 定义了自己的数据包结构，针对 RC 控制信号（通道数据）和遥测数据进行了优化，力求高效和低延迟。 跳频扩频 (FHSS): 为了进一步抵抗干扰和提高链路的鲁棒性，ELRS 在多个预设的信道之间快速切换频率进行通信。发射机和接收机使用同步的跳频序列。 绑定机制: 发射机（TX）和接收机（RX）通过一个用户设定的“绑定短语”（Binding Phrase）进行安全配对。只有拥有相同绑定短语的设备才能建立连接，防止被其他设备控制。 同步: 发射机和接收机需要精确同步它们的时钟和跳频序列才能成功通信。 软件固件: ELRS 固件运行在发射机和接收机模块的 MCU 上。 发射端 (TX): 固件从遥控器（通过串行端口如 CRSF 协议）读取用户的控制输入，将其打包成 ELRS 格式，控制 SX12xx 芯片进行调制、跳频并发射。同时接收来自接收机的遥测数据并传回遥控器显示。 接收端 (RX): 固件控制 SX12xx 芯片接收信号，进行解调和跳频同步。接收到有效数据包后，解包并将控制数据通过串行端口（通常是 CRSF 协议）发送给飞控或其他伺服设备。同时，它可以从飞控收集遥测数据，打包并发回给发射机。 CRSF协议介绍什么是 CRSF 协议？CRSF (Crossfire Protocol) 是由 Team BlackSheep (TBS) 公司为其 Crossfire 远程无线电控制 (RC) 系统开发的一种双向串行通信协议。它主要用于在 RC 发射机（或其射频模块）与 RC 接收机（或飞行控制器）之间传输控制信号和遥测数据。 由于其高效、低延迟和强大的功能集，CRSF 已成为现代 RC 系统（包括 ExpressLRS、Tracer 等）和飞行控制器固件（如 Betaflight, INAV, ArduPilot）中广泛采用的事实标准。 主要特点 双向通信: 支持从发射机到接收机&#x2F;飞控的 RC 通道数据传输，以及从接收机&#x2F;飞控到发射机的遥测数据（如信号强度、电池电压、GPS 等）回传。 串行传输: 通常通过 UART (通用异步收发传输器) 接口进行通信，物理连接简单。 高效率: 采用紧凑的二进制数据帧格式，减少了传输开销。 低延迟: 设计目标之一就是最小化控制链路的延迟。 高数据包速率: 支持较高的更新频率，以匹配 ELRS 等高性能 RC 链路。 可扩展性: 协议定义了多种帧类型，可以传输各种遥测信息，并支持设备发现、配置等高级功能。 广泛支持: 被众多开源和商业 RC 产品及飞控固件支持。 通信流程CRSF 通信是主从式的，通常： 发射机&#x2F;TX 模块 -&gt; 接收机&#x2F;飞控: 发送 RC 通道数据（包含摇杆、开关等位置信息）。 发送设备查询 (Ping) 消息。 发送配置命令。 接收机&#x2F;飞控 -&gt; 发射机&#x2F;TX 模块: 响应设备查询，发送设备信息。 主动发送遥测数据帧，如： 链路统计信息 (RSSI, LQ, SNR) 电池传感器信息 (电压, 电流, 容量) GPS 位置信息 姿态信息 飞行模式 等等… 帧结构CRSF 使用二进制帧格式，其基本结构如下： 1&lt;Device Address&gt; &lt;Frame Length&gt; &lt;Frame Type&gt; &lt;Payload&gt; &lt;CRC8&gt; Device Address (1 byte): 帧的目标或来源设备地址（同步字节）。常见地址： 0xC8: 飞行控制器 (Flight Controller) 0xEA: 无线电发射机 (Radio Transmitter) 0xEE: 接收机 (Receiver) 0xEF: TBS Core PNP Pro … 其他地址用于不同设备 Frame Length (1 byte): Frame Type + Payload + CRC8 的总字节数。最大长度通常限制在 62 字节（总帧长 64 字节）。 Frame Type (1 byte): 定义了 Payload 中包含的数据类型。 Payload (Variable length): 实际的数据内容，其结构由 Frame Type 决定。 CRC8 (1 byte): 循环冗余校验码，用于校验从 Frame Type 开始到 Payload 结束的数据完整性。通常使用 CRC-8-DVB-S2 多项式 (0xD5)。 常见帧类型示例 0x16: CRSF_FRAMETYPE_RC_CHANNELS_PACKED - 包含压缩的 RC 通道数据（通常是 16 个通道，每个通道 11 位）。这是从发射机到接收机&#x2F;飞控最核心的数据帧。 0x14: CRSF_FRAMETYPE_LINK_STATISTICS - 包含链路统计信息，如上行&#x2F;下行 RSSI、LQ (链路质量)、SNR (信噪比) 等。 0x08: CRSF_FRAMETYPE_BATTERY_SENSOR - 包含电池信息，如电压 (mV)、电流 (cA)、已用容量 (mAh)。 0x02: CRSF_FRAMETYPE_GPS - 包含 GPS 信息，如经度、纬度、地速、高度、卫星数等。 0x28: CRSF_FRAMETYPE_DEVICE_PING - 设备查询帧。 0x29: CRSF_FRAMETYPE_DEVICE_INFO - 设备信息响应帧，包含设备名称、硬件&#x2F;软件版本等。 0x07: CRSF_FRAMETYPE_ATTITUDE - 包含姿态信息（俯仰、滚转、偏航角）。 物理层 (UART) 接口: 标准 UART (TX, RX 引脚)。 电平: 通常为 3.3V TTL 电平。 参数: 8 数据位, 无校验位, 1 停止位 (8N1)。 波特率: 常见的波特率包括 115200 bps, 400000 bps, 420000 bps 等。ELRS 通常使用较高的波特率（如 400k 或更高）以匹配其高数据包速率。发射机和接收机&#x2F;飞控必须配置为使用相同的波特率。 硬件设计发射端和接收端的硬件设计在核心连接上类似，主要区别在于与外部设备（遥控器或飞控）的接口。 2.1. 通用硬件要求 (TX 和 RX) 主控 MCU 选择: 推荐: ESP32 系列 (因其性能、成本和 ELRS 社区广泛支持)。STM32 系列 (如 STM32F1, F4 等) 也是可选方案。 要求: 高速 SPI 接口 (数据手册建议 &lt;&#x3D; 10MHz, CPOL&#x3D;0, CPHA&#x3D;0)。 足够的 GPIO 引脚用于连接模块的控制线 (NSS, RST, BUSY, DIO1, DIO2, DIO3, TXEN, RXEN)。 至少一个 UART 接口用于与遥控器&#x2F;飞控通信 (通常使用 CRSF 协议) 或用于调试&#x2F;烧录。 足够的 Flash 和 RAM 以运行 ELRS 固件。 VG2392S240X0M2 模块与 MCU 连接: 电源 (VCC, GND): 提供稳定的 3.1V 至 3.6V 电源，典型值为 3.3V (手册 Page 4)。 强烈建议使用低噪声 LDO 为模块供电 (手册 Page 8)。 在模块 VCC 引脚附近放置滤波电容，如 100nF 和 10uF (手册 Page 7 电路图示例)。 确保良好的接地，将模块的 GND 引脚 (Pin 2, 15) 连接到 MCU 的地。 SPI 接口: MCU MOSI -&gt; 模块 MOSI (Pin 6) MCU MISO &lt;- 模块 MISO (Pin 7) MCU SCK -&gt; 模块 SCK (Pin 4) MCU NSS -&gt; 模块 NSS (Pin 3) 控制引脚: MCU GPIO -&gt; 模块 RST (Pin 8, 低电平有效复位) MCU GPIO &lt;- 模块 BUSY (Pin 9, 高电平表示模块忙) MCU GPIO (中断输入) &lt;- 模块 DIO1 (Pin 10, 用于 TxDone, RxDone 等中断) MCU GPIO &lt;-&gt; 模块 DIO2 (Pin 11, 可配置功能，ELRS 可能用于天线切换或其他) MCU GPIO &lt;-&gt; 模块 DIO3 (Pin 12, 可配置功能) PA&#x2F;LNA 控制 (关键): MCU GPIO -&gt; 模块 TXEN (Pin 13, 发射使能，高电平有效) MCU GPIO -&gt; 模块 RXEN (Pin 14, 接收使能，高电平有效) 注意: ELRS 固件必须根据当前操作（发射、接收、空闲&#x2F;休眠）精确控制这两个引脚的电平 (逻辑见手册 Page 13)。 天线: 选择: 模块提供三种天线连接方式：板载 PCB 天线 (默认)、IPEX-1 座、邮票孔半孔 (手册 Page 5)。 跳线电阻: 如果不使用默认的板载 PCB 天线，需要根据手册 Page 9 的图示修改模块内部的 0 欧姆跳线电阻，将信号路径切换到 IPEX 座或邮票孔 ANT 引脚 (Pin 1)。 外部天线: 若使用外部天线 (通过 IPEX 或邮票孔)，需选择 2.4GHz 频段、50 欧姆阻抗的天线。 RF 走线 (若使用邮票孔): 从模块 ANT 引脚 (Pin 1) 到天线连接器的 PCB 走线应尽可能短、直，保持 50 欧姆特性阻抗。遵循手册 Page 9-10 的 RF 走线和拐弯建议。避免直角拐弯，推荐圆弧或 45 度角。 布局: 确保天线（尤其是板载 PCB 天线）远离金属外壳、电池、大型元器件和 PCB 接地铜皮覆盖区域，以保证辐射效率 (手册 Page 11)。 2.2. 发射端 (TX) 特定设计 与遥控器接口: 通常通过 UART 连接到遥控器主板，使用 CRSF 协议传输通道数据和接收遥测数据。 用户接口 (可选): 可添加按钮用于绑定或功能切换，添加 LED 指示灯显示电源、连接状态、遥测状态等。 2.3. 接收端 (RX) 特定设计 与飞控接口: 通常通过 UART 连接到飞控，使用 CRSF 协议发送控制指令和接收遥测数据请求。 用户接口 (可选): 可添加 LED 指示灯显示电源、连接状态、绑定状态等。 软件设计软件设计的核心是配置和编译适用于该硬件组合的 ELRS 固件。 获取固件: 使用官方 ExpressLRS Configurator 工具，这是最简单的方式。 或者从 ExpressLRS GitHub 仓库 (https://github.com/ExpressLRS/ExpressLRS) 获取源码，使用 PlatformIO 进行编译。 硬件目标 (Target) 配置: 关键步骤: 需要在 ELRS Configurator 或 PlatformIO 环境中选择或定义一个硬件目标，该目标必须与您使用的 MCU 以及 VG2392S240X0M2 模块的引脚连接相匹配。 PA&#x2F;LNA 控制: 由于此模块带有外部 PA&#x2F;LNA，必须选择一个支持 TXEN 和 RXEN 引脚控制的 ELRS 硬件目标配置。如果官方没有完全匹配的预设目标，您可能需要： 查找基于相同 MCU 且使用类似 PA&#x2F;LNA 控制方式 (如 RadioMaster Ranger Micro 2.4GHz 等) 的目标作为参考。 或者，在 PlatformIO 中创建自定义硬件布局 (Hardware Layout)，在对应的 .ini 文件或 user_defines.txt &#x2F; hardware.h 中正确定义 RADIO_TXEN_PIN 和 RADIO_RXEN_PIN 所连接的 MCU GPIO 引脚号。 引脚定义: 确保配置文件中定义的 SPI (MOSI, MISO, SCK, NSS)、RST、BUSY、DIO1 (IRQ) 引脚与硬件连接一致。DIO2&#x2F;DIO3 根据 ELRS 目标是否使用它们来决定是否需要定义。 关键固件配置参数: Regulatory Domain: 选择 ISM_2400。 Binding Phrase: 为 TX 和 RX 设置相同的绑定短语。 TX&#x2F;RX Role: 分别为发射端和接收端固件选择 TX 或 RX。 Radio Output Power (重要!): 模块手册 (Page 4, 12) 指出，当 SX1281 内部输出设置为 0dBm 时，模块最终输出可达 27dBm。 因此，在 ELRS 固件配置中，不能直接设置目标输出功率为 27dBm。您需要配置 ELRS，使其驱动 SX1281 芯片输出较低的功率（例如 0dBm 或根据实际 PA 增益计算得出的值）。 具体的配置方式依赖于所选的 ELRS 硬件目标。通常在硬件配置文件 (hardware.h 或类似文件) 中会有功率相关的定义，需要确保这些定义与模块的 PA 增益相匹配，以避免损坏 PA 或输出功率超标。务必仔细查阅所选 ELRS 目标关于功率设置的说明，或在自定义目标时正确设置功率表。 手册建议 SX1281 输出不要超过 5dBm (Page 12)。 Packet Rate &#x2F; Telemetry Ratio: 根据需求选择合适的速率和遥测比率。 编译与烧录: 使用 ELRS Configurator 或 PlatformIO 编译固件。 通过 USB 转串口工具或其他烧录方式将编译好的固件分别烧录到 TX 和 RX 模块的 MCU 中。 参考文档 ELRS官方网站","tags":[]},{"title":"pt-questions","date":"2025-03-30T15:14:24.000Z","path":"2025/03/30/pt_questions/","text":"PT问题解答-20250330实训相关实训可以用竞赛顶替，任何竞赛都可以，只是分数高低的问题，如果不卷分数的话直接随便拿个奖顶掉就行，如果没奖甚至可以用银杏果或者大创项目抵掉 关于实训是否有价值，我个人认为学校合作的企业实训没有任何价值，有这时间不如自己搞点项目玩 应抵尽抵 实习相关因为个人经历问题，这里描述的都是企业实习相关的内容 方向方面当前就业方向很多，很宽泛，很难说谁适合什么方向，但是如果是本科生就业，技术岗位一般集中于下面几个方向： 前端开发 后端开发 嵌入式开发 测试岗位 移动端开发（有时并入前后端开发） 系统架构方向 运维开发方向（可能有些岗位会涉及到AI infra） 同时也有一些小众一些但是难度较高的技术岗位方向： 网络安全方向（CTF大手子？） 量化金融方向（一般侧重于高性能计算） AI方向（本科就业可能会比较难） 硬件电子方向（本科就业纯牛马，不推荐） 除了技术之外还有一些非技术或者单纯和技术沾边的方向： 产品经理（吃经验，想往这个方向走最好实习就冲） 部门HR？（这我还真没了解过） FAE（Field Application Engineer 现场应用工程师），不好评，分企业，有的纯牛马 销售？ ……. 能力方面不同方向的岗位需要不同的能力，具体的能力要求可以参考你感兴趣的岗位JD要求。可以去翻翻招聘软件或者你感兴趣的公司的官网，找到你感兴趣的岗位，看看有什么要求，一般JD要求的能力会比较杂，你精通其中的一两个其实就可以去投递，大胆开投，大不了被挂。 能力不求面面俱到，但求专精。 这里列举一些嵌入式软件开发能力（介绍的算是比较全面了，并不一定全部掌握，下面全是口胡）： 熟练使用C&#x2F;C++，CMake ，Makefile，shell ， python等语言 熟练掌握STM32&#x2F;GD32&#x2F;各类MCU的外设驱动开发（SPI，IIC，UART，DMA，CAN，USB），熟悉传感器开发流程 熟悉RTOS移植和内核工作原理，熟练使用至少一种RTOS 能够看懂原理图，PCB图，会使用示波器，逻辑分析仪，频谱仪等测试设备 熟练掌握常用的嵌入式开发环境的搭建和使用，熟悉linux系统的使用（看起来很容易，但是确实是嵌入式开发当中很重要的能力） linux kernel移植，功能裁切，linux驱动开发，uboot kernel rootfs及烧录，启动，调试。 还有很多，比如传感器方面的驱动开发，标定校准；系统调试调优，负载优化；摄像头，嵌入式音视频开发，Camera 3A算法开发，编解码开发。。。。 岗位方面可以根据自己的兴趣进行选择，可以广撒网多捞鱼的去选择，不要在一棵树上吊死，不要局限于一个方向，也不一定全投开发 不同的岗位可以针对性的优化自己的简历，不要多个岗位使用同一份简历，简历上重点突出他们需要的能力，不要大杂烩（我就很吃这方面亏） boss直聘，实习僧，公司官网。。。。都可以去投 关于竞赛和成绩竞赛其实在面试中算是锦上添花，但是其实很多比赛面试官连听都没听过，他会让你去讲你们比赛都做了什么，如果你擅长讲故事的话，确实可以写上去加分。 当然一些硬核的比赛还是很加分的，比如什么ACM&#x2F;ICPC&#x2F;CTF&#x2F;超算大赛&#x2F;RM&#x2F;RC。。。。，但是这些一般也很难拿奖（） 至少我面试的很多公司对于比赛不是很重视（可能都是牛马岗） 关于成绩，只要不要太离谱，一般没事，GPA比较低的可以在简历上不写，GPA 3.5以上我认为都可以写上去，问题不大 写在最后人生是旷野，我在这里讲的都是我的眼光能看到的，但是我的眼光可能也是狭隘的，我上面的建议不一定适合所有人，每个人热爱的和适合的都不一样，还是希望大家能够根据自己的热爱去选择岗位，活出自己独一无二，多姿多彩的人生。 Any Question？QWQ","tags":[]},{"title":"MFly-Hardware","date":"2025-02-19T10:12:21.000Z","path":"2025/02/19/MFly-Hardware/","text":"飞行器硬件设计本文主要记录飞行器硬件设计的过程,以及一些问题记录. 本飞行器旨在作为一个低成本的实验平台完成相关算法和工程落地实践 飞行器硬件拓扑飞机整体硬件拓扑 飞控硬件拓扑 遥控器硬件拓扑 飞控SOC域硬件设计核心板部分核心板部分是使用som-rk3399核心板,如图所示: SOM-RK3399核心板俯视图 SOM-RK3399是友善电子团队设计的一款266-pin金手指形式高性能ARM计算机模块，它采用了瑞芯微64位六核SoC RK3399作为主处理器，标配2GB DDR3内存和16GB闪存，板载2x2 MIMO双天线WiFi模组，尺寸只有69.6x50mm，模块上带有独立的TypeC供电接口，以及USB-C显示接口，无需底板也可以单独使用。 SOM-RK3399计算模块具有丰富的外设和扩展接口，通过底板可连接使用4通道NVMe高速固态硬盘，读写速度高达1GB&#x2F;s; 它还可以扩展使用双MIPI宽动态摄像头，另外它还带有eDP显示接口，MIPI显示接口, 1路USB3.0, 2路USB2.0, 以及I2C, I2S, SPI, PWM, GPIO和串口等各种资源。 相关核心板硬件部分可以参考链接:https://wiki.friendlyelec.com/wiki/index.php/SOM-RK3399/zh 该核心板使用0.5mm Pitch 260-Pin Standard Type DDR4 SODIMM Socket卡槽, 参考型号为:https://www.te.com/usa-en/product-2309409-5.html 根据卡槽引脚定义可以绘制相关原理图: SOM-RK3399硬件引脚图 HDMI电路部分核心板中引出了HDMI接口的引脚,我们需要在底板上进行实现,其中HDMI引脚电路如图所示: 底板HDMI原理图 SD卡电路部分核心板引出了SDMMC0相关引脚,这部分引脚可以画SD卡模块的电路,下面是这部分的原理图: 底板SD卡模块原理图 RJ45网口模块核心板上有一个PHY芯片,引出以太网引脚,下方为RJ45模块原理图: RJ45模块原理图 USB网卡电路USB网卡使用的是BL-M8812EU2,打算使用这个芯片作为图传芯片使用,原理图如下,封装使用的是自己画的封装,存在部分小瑕疵,但是并不影响使用: USB网卡模块原理图 电源方案汇总注意电阻选择上，有些数值在绘制的时候需要使用叠加来凑数 12V -&gt; 5V方案使用MP2236GJ-Z芯片 datasheet 主要特点和典型电路如下: 支持3V-18V输入,6A输出,对于此方案下,12V输入,5V输出的要求,绘制原理图如下: 12V -&gt; 3.3V方案依旧使用MP2236GJ-Z芯片 datasheet设计方案同上，但是在buck电阻上存在数据差别 飞控传感器部分气压计ICP-20100datasheet中的典型电路： image-20250226201805401 飞控外设分配 image-20250227202626796 参考文档 SOM-RK3399文档 MP2236GJ-Z datasheet 附录1 芯片选择部分芯片选型原则： 有完整的芯片数据手册，有参考设计方案 最好有相应的封装库进行设计，但是如果使用lceda进行设计需要审核一下使用的封装是否正确 选择可以在电商平台买到的芯片进行设计 附录2 打板前CheckList 检查项 是否完成 备注 电源电阻是否已经完成凑数 - [ ] 图传网卡需要独立出一块小板 - [ ] MIPI屏幕在第一版上暂时取消 - [ ]","tags":[{"name":"硬件,四轴","slug":"硬件-四轴","permalink":"https://dailynobug.github.io/tags/%E7%A1%AC%E4%BB%B6-%E5%9B%9B%E8%BD%B4/"}]},{"title":"run-ollama-in-docker","date":"2025-01-15T15:06:31.000Z","path":"2025/01/15/run-ollama-in-docker/","text":"Run Ollama in dockerinstall nvidia container toolkithttps://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html#installation Installing with Apt Configure the production repository: 1234$ curl -fsSL https:&#x2F;&#x2F;nvidia.github.io&#x2F;libnvidia-container&#x2F;gpgkey | sudo gpg --dearmor -o &#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;nvidia-container-toolkit-keyring.gpg \\ &amp;&amp; curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;libnvidia-container&#x2F;stable&#x2F;deb&#x2F;nvidia-container-toolkit.list | \\ sed &#39;s#deb https:&#x2F;&#x2F;#deb [signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;nvidia-container-toolkit-keyring.gpg] https:&#x2F;&#x2F;#g&#39; | \\ sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-container-toolkit.list Optionally, configure the repository to use experimental packages: 1$ sed -i -e &#39;&#x2F;experimental&#x2F; s&#x2F;^#&#x2F;&#x2F;g&#39; &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-container-toolkit.list Update the packages list from the repository: 1$ sudo apt-get update Install the NVIDIA Container Toolkit packages: 1$ sudo apt-get install -y nvidia-container-toolkit Start the container1docker run -d --gpus=all -v ollama:/root/.ollama -p 11434:11434 --name ollama ollama/ollama exec the container1docker exec -it ollama /bin/bash webui可以编写一个flask应用来实现简单的webui： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from flask import Flask, request, jsonify, render_template_stringapp = Flask(__name__)# Ollama API的基本URLOLLAMA_API_URL = \"https://api.ollama.com/v1/generate\"@app.route('/')def index(): return render_template_string(''' &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Chat with Ollama&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome to the Chat Interface!&lt;/h1&gt; &lt;form id=\"chatForm\" method=\"post\" action=\"/chat\"&gt; &lt;input type=\"text\" name=\"message\" placeholder=\"Type your message here...\"&gt; &lt;button type=\"submit\"&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;div id=\"response\"&gt;&lt;/div&gt; &lt;script&gt; document.getElementById('chatForm').addEventListener('submit', function(e) &#123; e.preventDefault(); const input = document.querySelector('input[name=message]'); const xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"/chat\"); xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.onload = function() &#123; if (xhr.status === 200) &#123; document.getElementById('response').innerText = xhr.responseText; &#125; else &#123; console.error(\"Request failed. Returned status of \", xhr.status); &#125; &#125;; const formData = new FormData(); formData.append(\"message\", input.value); xhr.send(formData); &#125;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ''')@app.route('/chat', methods=['POST'])def chat(): user_input = request.form.get('message') # 构建API请求参数 payload = &#123; 'prompt': f\"User: &#123;user_input&#125;\\nAssistant:\", 'model': \"your_model_name_here\", # 替换为你使用的模型名称 'max_new_tokens': 100 # 设置生成的最大新令牌数量 &#125; try: response = requests.post(OLLAMA_API_URL, json=payload) response.raise_for_status() generated_text = response.json()['choices'][0]['text'] return jsonify(&#123;'response': generated_text&#125;) except Exception as e: return jsonify(&#123;'error': str(e)&#125;), 500if __name__ == '__main__': app.run(debug=True) 同时需要html文件： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Chat with Ollama&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Welcome to the Chat Interface!&lt;/h1&gt; &lt;form id=\"chatForm\" method=\"post\" action=\"/chat\"&gt; &lt;input type=\"text\" name=\"message\" placeholder=\"Type your message here...\"&gt; &lt;button type=\"submit\"&gt;Send&lt;/button&gt; &lt;/form&gt; &lt;div id=\"response\"&gt;&lt;/div&gt; &lt;script&gt; document.getElementById('chatForm').addEventListener('submit', function(e) &#123; e.preventDefault(); const input = document.querySelector('input[name=message]'); const xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"/chat\"); xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.onload = function() &#123; if (xhr.status === 200) &#123; document.getElementById('response').innerText = xhr.responseText; &#125; else &#123; console.error(\"Request failed. Returned status of \", xhr.status); &#125; &#125;; const formData = new FormData(); formData.append(\"message\", input.value); xhr.send(formData); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[]},{"title":"uboot-1","date":"2025-01-15T11:11:51.000Z","path":"2025/01/15/uboot-1/","text":"UBOOT 学习笔记执行流程1. 上电与ROM代码执行 上电后，ROM代码（BootROM）启动：这是存储在SoC中的固件，负责引导过程的第一阶段。它会从预定义的启动设备（如eMMC、SD卡、SPI Flash等）加载引导程序。 2. 第一阶段引导加载器（SPL） SPL（Secondary Program Loader）：通常是U-Boot的一个精简版本，负责初始化基本的硬件（如DDR内存），并加载U-Boot的完整版本。 加载并执行U-Boot：SPL将U-Boot从存储设备加载到内存中，然后跳转到U-Boot的入口点。 3. U-Boot执行 硬件初始化：U-Boot完成更多的硬件初始化，包括设置时钟、初始化串口、配置网络等。 设备树加载：加载设备树文件（DTB），这描述了硬件的配置和连接。 选择引导源：根据环境变量或默认配置，选择从哪个设备加载操作系统内核（如eMMC、SD卡、网络等）。 加载内核和initrd：将Linux内核和初始RAM盘（initrd&#x2F;initramfs）加载到内存中。 设置内核参数：通过命令行参数向内核传递必要的信息（如根文件系统的位置）。 4. 启动Linux内核 跳转到内核入口：U-Boot将控制权交给Linux内核，内核开始执行。 内核初始化：Linux内核进行硬件检测和初始化，加载必要的驱动程序，并挂载根文件系统。 5. 用户空间启动 init进程启动：内核启动第一个用户空间进程（通常是/sbin/init），这开始了用户空间的初始化。 启动服务和登录界面：根据系统配置，启动各种系统服务和提供用户登录界面。","tags":[]},{"title":"open-project","date":"2024-06-30T16:14:24.000Z","path":"2024/06/30/open-project/","text":"开源项目收集本文档收集一些有意思的开源项目： linenoiselinenoise 是一个轻量级、跨平台的 C 语言库，用于命令行输入的处理。该项目最初是由 Salvatore Sanfilippo (antirez) 创建的，以提供一个简单、高效的替代方案，取代 GNU Readline 和 libedit 库。linenoise 的设计目标是保持最小化的代码库，同时提供足够的功能以满足大多数命令行应用程序的需求。 特点 轻量级：linenoise 的代码非常简洁，仅包含几个文件，使其易于理解和维护。 跨平台：支持多种操作系统，包括 Linux、MacOS 和 Windows。 无依赖：不依赖于任何第三方库，仅使用标准 C 库函数。 Unicode 支持：能够正确处理多字节字符和 Unicode 字符。 历史记录管理：支持命令历史记录，可以方便地浏览和编辑之前输入的命令。 自动补全：提供简单的自动补全功能，方便用户快速输入命令。 主要功能 行编辑：支持基本的行编辑功能，如删除、插入、左右移动光标等。 历史记录：可以记录用户输入的历史命令，并在命令行中上下浏览历史记录。 自动补全：通过提供回调函数，可以实现命令的自动补全功能。 多行支持：能够正确处理和显示多行输入。 链接：https://github.com/antirez/linenoise taipyTaipy 是一个用于创建数据驱动应用程序的 Python 库。它旨在帮助开发者快速构建、部署和管理数据科学应用程序，简化了数据流的构建和用户界面的设计。Taipy 通过一组高效的工具和框架，提供了一种灵活且易于使用的方法来处理复杂的数据科学任务。 特点 易于使用：提供简洁的 API 和高层次的抽象，使得开发者能够快速上手，减少了编写样板代码的时间。 灵活性：允许开发者自定义数据流和用户界面，以满足特定的业务需求。 可视化：内置丰富的图表和可视化组件，使得数据展示和交互变得更加直观。 扩展性：支持集成第三方库和工具，能够扩展其功能以适应更多的数据科学场景。 高效性：优化了数据处理和流管理，确保应用程序在大数据环境下的高效运行。 主要组件Taipy 包含几个关键组件，每个组件都专注于特定的功能领域： Taipy Core：用于定义和管理数据流和任务调度的核心库。它帮助开发者设计数据处理管道，并确保任务按顺序执行。 Taipy GUI：用于创建交互式用户界面的工具包。它提供了多种图表和控件，使得数据展示更加生动。 Taipy Config：用于配置和管理应用程序设置的模块。它允许开发者灵活地定义和调整应用程序的行为。 Taipy REST：用于构建 RESTful API 接口，使得应用程序可以轻松地与其他系统或服务进行通信。 链接：https://github.com/Avaiga/taipy kcphttps://github.com/skywind3000/kcp 项目背景KCP 是一个高效、轻量级的可靠 UDP 协议库，由开发者 skywind3000 创建并维护。它旨在通过 UDP 提供比 TCP 更低延迟、更灵活的数据传输能力，尤其适合对实时性要求高的场景（如游戏、实时音视频传输等）。 核心特点 低延迟设计 通过 ARQ（自动重传请求） 机制实现可靠传输，但优化了重传策略，减少等待时间。 对比 TCP 的“延迟 ACK”和“拥塞控制”，KCP 允许用户自定义参数（如 RTO、窗口大小），以平衡延迟与吞吐量。 高效传输 支持 选择性重传（仅重传丢失的包），而非传统 TCP 的“全部重传”。 提供 快速重传 机制，通过重复 ACK 快速检测丢包。 轻量与跨平台 纯 C 实现，代码简洁（核心代码约 1,000 行），易于集成到各类项目中。 支持 Windows、Linux、macOS 及移动端，并可嵌入到 C&#x2F;C++、Go、Rust 等语言生态。 灵活配置 提供多种模式（如普通模式、极速模式），用户可根据场景调整参数（如 nodelay、interval、resend 等）。 适用场景 游戏开发：MOBA、FPS 等对延迟敏感的游戏。 实时通信：音视频流、直播、视频会议。 物联网（IoT）：弱网环境下的设备间通信。 P2P 网络：需要高效可靠传输的分布式系统。 性能对比在相同带宽下，KCP 的延迟通常比 TCP 低 30%-40%，尤其在网络波动较大时表现更优。例如，在 10% 丢包率下，KCP 的吞吐量仍能接近理论最大值。 使用方式 集成源码：直接包含 ikcp.h 和 ikcp.c 到项目中。 配置参数：根据场景调整模式与参数（如 ikcp_nodelay 开启极速模式）。 绑定 UDP Socket：通过回调函数与 UDP 结合，实现数据收发。","tags":[]},{"title":"hijack_mac","date":"2024-06-17T01:17:51.000Z","path":"2024/06/17/hijack_mac/","text":"mac地址欺骗系统调用劫持通过劫持系统调用，可以拦截和修改应用程序请求的硬件信息，如 MAC 地址。 使用 LD_PRELOAD 劫持 getifaddrs 系统调用 编写劫持库： 创建一个共享库，劫持 getifaddrs 系统调用以返回伪造的 MAC 地址。 1234567891011121314151617181920212223242526272829303132333435363738394041#define _GNU_SOURCE#include &lt;dlfcn.h&gt;#include &lt;ifaddrs.h&gt;#include &lt;netpacket/packet.h&gt;#include &lt;net/if.h&gt;#include &lt;stdio.h&gt;int getifaddrs(struct ifaddrs **ifap) &#123; // 获取原始的 getifaddrs 函数 int (*original_getifaddrs)(struct ifaddrs **); original_getifaddrs = dlsym(RTLD_NEXT, \"getifaddrs\"); // 调用原始 getifaddrs 函数 int result = original_getifaddrs(ifap); if (result != 0) &#123; return result; &#125; // 打印调试信息 printf(\"getifaddrs called\\n\"); // 遍历接口列表并修改 MAC 地址 struct ifaddrs *ifa = *ifap; while (ifa) &#123; if (ifa-&gt;ifa_addr &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family == AF_PACKET) &#123; struct sockaddr_ll *s = (struct sockaddr_ll *)ifa-&gt;ifa_addr; // 修改 MAC 地址 s-&gt;sll_addr[0] = 0x02; s-&gt;sll_addr[1] = 0x42; s-&gt;sll_addr[2] = 0xac; s-&gt;sll_addr[3] = 0x11; s-&gt;sll_addr[4] = 0x00; s-&gt;sll_addr[5] = 0x02; // 打印调试信息 printf(\"Modified MAC address for interface %s\\n\", ifa-&gt;ifa_name); &#125; ifa = ifa-&gt;ifa_next; &#125; return result;&#125; 编译共享库： 1gcc -shared -fPIC -o libspoof_mac.so spoof_mac.c -ldl 使用 LD_PRELOAD 运行目标程序： 1LD_PRELOAD=./libspoof_mac.so ./target_program 如果出现mac地址欺骗未成功，可以尝试劫持其他相关系统调用，例如 ioctl SIOCGIFHWADDR 是一个特定的 ioctl 请求码，用于获取网络接口的硬件地址（MAC 地址）。ioctl 是一个通用的输入&#x2F;输出控制接口，可以对设备文件进行各种操作，而 SIOCGIFHWADDR 则专门用于网络设备。 SIOCGIFHWADDR 的使用当一个程序想要获取某个网络接口的 MAC 地址时，会使用 ioctl 系统调用并传递 SIOCGIFHWADDR 请求码。这个请求码指示内核返回指定网络接口的硬件地址。 请求的结构在使用 SIOCGIFHWADDR 请求时，通常需要一个 struct ifreq 结构体作为参数。该结构体定义在 &lt;net/if.h&gt; 头文件中，主要包含网络接口的名称和相关信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _GNU_SOURCE#include &lt;dlfcn.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;net/if.h&gt;#include &lt;netpacket/packet.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;// 定义劫持的 ioctl 函数int ioctl(int fd, unsigned long request, ...) &#123; static int (*original_ioctl)(int, unsigned long, ...); if (!original_ioctl) &#123; original_ioctl = dlsym(RTLD_NEXT, \"ioctl\"); &#125; va_list args; va_start(args, request); int ret; if (request == SIOCGIFHWADDR) &#123; struct ifreq *ifr = va_arg(args, struct ifreq *); ret = original_ioctl(fd, request, ifr); if (ret == 0) &#123; // 打印调试信息 printf(\"Intercepted SIOCGIFHWADDR for interface: %s\\n\", ifr-&gt;ifr_name); // 修改 MAC 地址 ifr-&gt;ifr_hwaddr.sa_data[0] = 0x02; ifr-&gt;ifr_hwaddr.sa_data[1] = 0x42; ifr-&gt;ifr_hwaddr.sa_data[2] = 0xac; ifr-&gt;ifr_hwaddr.sa_data[3] = 0x11; ifr-&gt;ifr_hwaddr.sa_data[4] = 0x00; ifr-&gt;ifr_hwaddr.sa_data[5] = 0x02; // 打印调试信息 printf(\"Modified MAC address for interface %s\\n\", ifr-&gt;ifr_name); &#125; &#125; else &#123; ret = original_ioctl(fd, request, va_arg(args, void *)); &#125; va_end(args); return ret;&#125;","tags":[]},{"title":"泰山派调试常用命令","date":"2024-06-17T01:17:51.000Z","path":"2024/06/17/泰山派调试常用命令/","text":"泰山派调试常用命令ubuntu下使用命令行连接wifi123456sudo iwlist scannmcli device wifi listnmcli device wifi connect &#123;ESSID&#125; password &#123;PASSWORD&#125;nmcli device wifi connect 404_2.4g password &quot;@404@404&quot; nmcli device wifi connect &quot;404_5g&quot; password &quot;@404@404@404&quot; ifname wlan0make modules_install INSTALL_MOD_PATH&#x3D;&lt;rootfs_path&gt; image-20250305184435807 image-20250305184444185 备忘录1234567891011121314151617181920 v4l2-ctl --list-devicesv4l2-ctl --list-formats-ext --device=/dev/video0v4l2-ctl -d /dev/video0 -Lv4l2-ctl --set-ctrl analogue_gain=80v4l2-ctl --verbose -d /dev/video0 --set-fmt-video=width=1920,height=1080,pixelformat='UYVY' --stream-mmap=20 --set-selection=target=crop,flags=0,top=0,left=0,width=1920,height=1080 --set-ctrl analogue_gain=80 --stream-to=/tmp/out.yuvv4l2-ctl --verbose -d /dev/video1 --set-fmt-video=width=1920,height=1080,pixelformat='UYVY' --stream-mmap=20 --stream-to=/tmp/out.yuvffmpeg -f v4l2 -input_format nv12 -video_size 1920x1080 -i /dev/video0 -c:v libx264 -preset ultrafast output.mp4ffmpeg -f v4l2 -i /dev/video0 -pixel_format yuv422p -framerate 15 -video_size 800x600 -c:v copy -f mpegts udp://@:1234ffmpeg -f v4l2 -input_format nv12 -video_size 1920x1080 -i /dev/video8 -t 10 output.yuvffmpeg -f rawvideo -pixel_format yuv422p -video_size 3840x2160 -framerate 24 -i out.yuv -c:v libx264 output.mp4scp lsc@192.168.115.129:/home/lsc/project/Release/kernel/boot.img ./ 硬件编码测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# -*- coding: utf-8 -*-import cv2import socketimport numpy as npimport time# --- 配置 ---TARGET_IP = \"192.168.3.71\" # 接收端电脑的 IP 地址 (运行 OBS 的电脑)TARGET_PORT = 1234 # 目标 UDP 端口 (与 OBS 设置一致)CAMERA_INDEX = 0 # 摄像头的索引 (通常是 0 或 1)JPEG_QUALITY = 70 # JPEG 编码质量 (0-100, 越高画质越好但数据量越大)SEND_RESOLUTION = (640, 480) # 发送的分辨率 (宽, 高)# --- 初始化 ---# 创建 UDP socketudp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 打开摄像头cap = cv2.VideoCapture(CAMERA_INDEX)if not cap.isOpened(): print(f\"错误：无法打开摄像头索引 &#123;CAMERA_INDEX&#125;\") exit()# 设置摄像头分辨率 (可选, 尝试设置)# cap.set(cv2.CAP_PROP_FRAME_WIDTH, SEND_RESOLUTION[0])# cap.set(cv2.CAP_PROP_FRAME_HEIGHT, SEND_RESOLUTION[1])print(f\"摄像头已打开。将推流到 UDP &#123;TARGET_IP&#125;:&#123;TARGET_PORT&#125;\")print(f\"发送分辨率: &#123;SEND_RESOLUTION&#125;, JPEG 质量: &#123;JPEG_QUALITY&#125;\")print(\"按 Ctrl+C 停止推流。\")try: while True: # 读取一帧 ret, frame = cap.read() if not ret: print(\"错误：无法读取摄像头帧。\") time.sleep(0.5) # 等待一下再试 continue # 调整帧大小 frame_resized = cv2.resize(frame, SEND_RESOLUTION) # 将帧编码为 JPEG encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY] result, encoded_frame = cv2.imencode('.jpg', frame_resized, encode_param) if not result: print(\"错误：JPEG 编码失败。\") continue # 将编码后的数据转换为字节 data = encoded_frame.tobytes() # 发送数据 # UDP 对于数据包大小有限制 (通常 &lt; 65507 字节) # 如果编码后的帧太大，可能会发送失败或被截断 if len(data) &gt; 65000: print(f\"警告：帧数据过大 (&#123;len(data)&#125; 字节)，可能无法完整发送。尝试降低分辨率或 JPEG 质量。\") # 可以选择跳过此帧或尝试发送 # continue # 选择跳过 try: udp_socket.sendto(data, (TARGET_IP, TARGET_PORT)) # print(f\"Sent frame: &#123;len(data)&#125; bytes\") # 取消注释以查看发送日志 except socket.error as e: print(f\"发送错误: &#123;e&#125;\") time.sleep(1) # 发送失败时稍作等待 # (可选) 稍微降低帧率，减轻 CPU 负担和网络拥堵 # time.sleep(0.01) # 约等于 100 FPS 的延迟，根据需要调整except KeyboardInterrupt: print(\"\\n停止推流...\")finally: # 清理资源 print(\"正在释放资源...\") cap.release() udp_socket.close() cv2.destroyAllWindows() # 如果在开发板上有显示窗口的话 print(\"资源已释放。\") 12345-&gt; Device Drivers │ │ -&gt; Multimedia support (MEDIA_SUPPORT [=y]) │ │ -&gt; Media drivers │ │ (1) -&gt; V4L platform devices (V4L_PLATFORM_DRIVERS [=y]) pip install opencv-python numpy sudo apt install -y libgl1","tags":[]}]