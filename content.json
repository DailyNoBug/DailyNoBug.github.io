[{"title":"MFly-Hardware","date":"2025-02-19T10:12:21.000Z","path":"2025/02/19/MFly-Hardware/","text":"飞行器硬件设计本文主要记录飞行器硬件设计的过程,以及一些问题记录. 本飞行器旨在作为一个低成本的实验平台完成相关算法和工程落地实践 飞行器硬件拓扑飞机整体硬件拓扑 img 飞控硬件拓扑 img 遥控器硬件拓扑 img 飞控MCU域硬件设计","tags":[]},{"title":"open-project","date":"2024-06-30T16:14:24.000Z","path":"2024/06/30/open-project/","text":"开源项目收集本文档收集一些有意思的开源项目： linenoiselinenoise 是一个轻量级、跨平台的 C 语言库，用于命令行输入的处理。该项目最初是由 Salvatore Sanfilippo (antirez) 创建的，以提供一个简单、高效的替代方案，取代 GNU Readline 和 libedit 库。linenoise 的设计目标是保持最小化的代码库，同时提供足够的功能以满足大多数命令行应用程序的需求。 特点 轻量级：linenoise 的代码非常简洁，仅包含几个文件，使其易于理解和维护。 跨平台：支持多种操作系统，包括 Linux、MacOS 和 Windows。 无依赖：不依赖于任何第三方库，仅使用标准 C 库函数。 Unicode 支持：能够正确处理多字节字符和 Unicode 字符。 历史记录管理：支持命令历史记录，可以方便地浏览和编辑之前输入的命令。 自动补全：提供简单的自动补全功能，方便用户快速输入命令。 主要功能 行编辑：支持基本的行编辑功能，如删除、插入、左右移动光标等。 历史记录：可以记录用户输入的历史命令，并在命令行中上下浏览历史记录。 自动补全：通过提供回调函数，可以实现命令的自动补全功能。 多行支持：能够正确处理和显示多行输入。 链接：https://github.com/antirez/linenoise taipyTaipy 是一个用于创建数据驱动应用程序的 Python 库。它旨在帮助开发者快速构建、部署和管理数据科学应用程序，简化了数据流的构建和用户界面的设计。Taipy 通过一组高效的工具和框架，提供了一种灵活且易于使用的方法来处理复杂的数据科学任务。 特点 易于使用：提供简洁的 API 和高层次的抽象，使得开发者能够快速上手，减少了编写样板代码的时间。 灵活性：允许开发者自定义数据流和用户界面，以满足特定的业务需求。 可视化：内置丰富的图表和可视化组件，使得数据展示和交互变得更加直观。 扩展性：支持集成第三方库和工具，能够扩展其功能以适应更多的数据科学场景。 高效性：优化了数据处理和流管理，确保应用程序在大数据环境下的高效运行。 主要组件Taipy 包含几个关键组件，每个组件都专注于特定的功能领域： Taipy Core：用于定义和管理数据流和任务调度的核心库。它帮助开发者设计数据处理管道，并确保任务按顺序执行。 Taipy GUI：用于创建交互式用户界面的工具包。它提供了多种图表和控件，使得数据展示更加生动。 Taipy Config：用于配置和管理应用程序设置的模块。它允许开发者灵活地定义和调整应用程序的行为。 Taipy REST：用于构建 RESTful API 接口，使得应用程序可以轻松地与其他系统或服务进行通信。 链接：https://github.com/Avaiga/taipy kcphttps://github.com/skywind3000/kcp 项目背景KCP 是一个高效、轻量级的可靠 UDP 协议库，由开发者 skywind3000 创建并维护。它旨在通过 UDP 提供比 TCP 更低延迟、更灵活的数据传输能力，尤其适合对实时性要求高的场景（如游戏、实时音视频传输等）。 核心特点 低延迟设计 通过 ARQ（自动重传请求） 机制实现可靠传输，但优化了重传策略，减少等待时间。 对比 TCP 的“延迟 ACK”和“拥塞控制”，KCP 允许用户自定义参数（如 RTO、窗口大小），以平衡延迟与吞吐量。 高效传输 支持 选择性重传（仅重传丢失的包），而非传统 TCP 的“全部重传”。 提供 快速重传 机制，通过重复 ACK 快速检测丢包。 轻量与跨平台 纯 C 实现，代码简洁（核心代码约 1,000 行），易于集成到各类项目中。 支持 Windows、Linux、macOS 及移动端，并可嵌入到 C&#x2F;C++、Go、Rust 等语言生态。 灵活配置 提供多种模式（如普通模式、极速模式），用户可根据场景调整参数（如 nodelay、interval、resend 等）。 适用场景 游戏开发：MOBA、FPS 等对延迟敏感的游戏。 实时通信：音视频流、直播、视频会议。 物联网（IoT）：弱网环境下的设备间通信。 P2P 网络：需要高效可靠传输的分布式系统。 性能对比在相同带宽下，KCP 的延迟通常比 TCP 低 30%-40%，尤其在网络波动较大时表现更优。例如，在 10% 丢包率下，KCP 的吞吐量仍能接近理论最大值。 使用方式 集成源码：直接包含 ikcp.h 和 ikcp.c 到项目中。 配置参数：根据场景调整模式与参数（如 ikcp_nodelay 开启极速模式）。 绑定 UDP Socket：通过回调函数与 UDP 结合，实现数据收发。","tags":[]},{"title":"hijack_mac","date":"2024-06-17T01:17:51.000Z","path":"2024/06/17/hijack_mac/","text":"mac地址欺骗系统调用劫持通过劫持系统调用，可以拦截和修改应用程序请求的硬件信息，如 MAC 地址。 使用 LD_PRELOAD 劫持 getifaddrs 系统调用 编写劫持库： 创建一个共享库，劫持 getifaddrs 系统调用以返回伪造的 MAC 地址。 1234567891011121314151617181920212223242526272829303132333435363738394041#define _GNU_SOURCE#include &lt;dlfcn.h&gt;#include &lt;ifaddrs.h&gt;#include &lt;netpacket/packet.h&gt;#include &lt;net/if.h&gt;#include &lt;stdio.h&gt;int getifaddrs(struct ifaddrs **ifap) &#123; // 获取原始的 getifaddrs 函数 int (*original_getifaddrs)(struct ifaddrs **); original_getifaddrs = dlsym(RTLD_NEXT, \"getifaddrs\"); // 调用原始 getifaddrs 函数 int result = original_getifaddrs(ifap); if (result != 0) &#123; return result; &#125; // 打印调试信息 printf(\"getifaddrs called\\n\"); // 遍历接口列表并修改 MAC 地址 struct ifaddrs *ifa = *ifap; while (ifa) &#123; if (ifa-&gt;ifa_addr &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family == AF_PACKET) &#123; struct sockaddr_ll *s = (struct sockaddr_ll *)ifa-&gt;ifa_addr; // 修改 MAC 地址 s-&gt;sll_addr[0] = 0x02; s-&gt;sll_addr[1] = 0x42; s-&gt;sll_addr[2] = 0xac; s-&gt;sll_addr[3] = 0x11; s-&gt;sll_addr[4] = 0x00; s-&gt;sll_addr[5] = 0x02; // 打印调试信息 printf(\"Modified MAC address for interface %s\\n\", ifa-&gt;ifa_name); &#125; ifa = ifa-&gt;ifa_next; &#125; return result;&#125; 编译共享库： 1gcc -shared -fPIC -o libspoof_mac.so spoof_mac.c -ldl 使用 LD_PRELOAD 运行目标程序： 1LD_PRELOAD=./libspoof_mac.so ./target_program 如果出现mac地址欺骗未成功，可以尝试劫持其他相关系统调用，例如 ioctl SIOCGIFHWADDR 是一个特定的 ioctl 请求码，用于获取网络接口的硬件地址（MAC 地址）。ioctl 是一个通用的输入&#x2F;输出控制接口，可以对设备文件进行各种操作，而 SIOCGIFHWADDR 则专门用于网络设备。 SIOCGIFHWADDR 的使用当一个程序想要获取某个网络接口的 MAC 地址时，会使用 ioctl 系统调用并传递 SIOCGIFHWADDR 请求码。这个请求码指示内核返回指定网络接口的硬件地址。 请求的结构在使用 SIOCGIFHWADDR 请求时，通常需要一个 struct ifreq 结构体作为参数。该结构体定义在 &lt;net/if.h&gt; 头文件中，主要包含网络接口的名称和相关信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _GNU_SOURCE#include &lt;dlfcn.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;net/if.h&gt;#include &lt;netpacket/packet.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;// 定义劫持的 ioctl 函数int ioctl(int fd, unsigned long request, ...) &#123; static int (*original_ioctl)(int, unsigned long, ...); if (!original_ioctl) &#123; original_ioctl = dlsym(RTLD_NEXT, \"ioctl\"); &#125; va_list args; va_start(args, request); int ret; if (request == SIOCGIFHWADDR) &#123; struct ifreq *ifr = va_arg(args, struct ifreq *); ret = original_ioctl(fd, request, ifr); if (ret == 0) &#123; // 打印调试信息 printf(\"Intercepted SIOCGIFHWADDR for interface: %s\\n\", ifr-&gt;ifr_name); // 修改 MAC 地址 ifr-&gt;ifr_hwaddr.sa_data[0] = 0x02; ifr-&gt;ifr_hwaddr.sa_data[1] = 0x42; ifr-&gt;ifr_hwaddr.sa_data[2] = 0xac; ifr-&gt;ifr_hwaddr.sa_data[3] = 0x11; ifr-&gt;ifr_hwaddr.sa_data[4] = 0x00; ifr-&gt;ifr_hwaddr.sa_data[5] = 0x02; // 打印调试信息 printf(\"Modified MAC address for interface %s\\n\", ifr-&gt;ifr_name); &#125; &#125; else &#123; ret = original_ioctl(fd, request, va_arg(args, void *)); &#125; va_end(args); return ret;&#125;","tags":[]}]