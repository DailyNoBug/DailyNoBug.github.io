[{"title":"pt-questions","date":"2025-03-30T15:14:24.000Z","path":"2025/03/30/pt_questions/","text":"PT问题解答-20250330实训相关实训可以用竞赛顶替，任何竞赛都可以，只是分数高低的问题，如果不卷分数的话直接随便拿个奖顶掉就行，如果没奖甚至可以用银杏果或者大创项目抵掉 关于实训是否有价值，我个人认为学校合作的企业实训没有任何价值，有这时间不如自己搞点项目玩 应抵尽抵 实习相关因为个人经历问题，这里描述的都是企业实习相关的内容 方向方面当前就业方向很多，很宽泛，很难说谁适合什么方向，但是如果是本科生就业，技术岗位一般集中于下面几个方向： 前端开发 后端开发 嵌入式开发 测试岗位 移动端开发（有时并入前后端开发） 系统架构方向 运维开发方向（可能有些岗位会涉及到AI infra） 同时也有一些小众一些但是难度较高的技术岗位方向： 网络安全方向（CTF大手子？） 量化金融方向（一般侧重于高性能计算） AI方向（本科就业可能会比较难） 硬件电子方向（本科就业纯牛马，不推荐） 除了技术之外还有一些非技术或者单纯和技术沾边的方向： 产品经理（吃经验，想往这个方向走最好实习就冲） 部门HR？（这我还真没了解过） FAE（Field Application Engineer 现场应用工程师），不好评，分企业，有的纯牛马 销售？ ……. 能力方面不同方向的岗位需要不同的能力，具体的能力要求可以参考你感兴趣的岗位JD要求。可以去翻翻招聘软件或者你感兴趣的公司的官网，找到你感兴趣的岗位，看看有什么要求，一般JD要求的能力会比较杂，你精通其中的一两个其实就可以去投递，大胆开投，大不了被挂。 能力不求面面俱到，但求专精。 这里列举一些嵌入式软件开发能力（介绍的算是比较全面了，并不一定全部掌握，下面全是口胡）： 熟练使用C&#x2F;C++，CMake ，Makefile，shell ， python等语言 熟练掌握STM32&#x2F;GD32&#x2F;各类MCU的外设驱动开发（SPI，IIC，UART，DMA，CAN，USB），熟悉传感器开发流程 熟悉RTOS移植和内核工作原理，熟练使用至少一种RTOS 能够看懂原理图，PCB图，会使用示波器，逻辑分析仪，频谱仪等测试设备 熟练掌握常用的嵌入式开发环境的搭建和使用，熟悉linux系统的使用（看起来很容易，但是确实是嵌入式开发当中很重要的能力） linux kernel移植，功能裁切，linux驱动开发，uboot kernel rootfs及烧录，启动，调试。 还有很多，比如传感器方面的驱动开发，标定校准；系统调试调优，负载优化；摄像头，嵌入式音视频开发，Camera 3A算法开发，编解码开发。。。。 岗位方面可以根据自己的兴趣进行选择，可以广撒网多捞鱼的去选择，不要在一棵树上吊死，不要局限于一个方向，也不一定全投开发 不同的岗位可以针对性的优化自己的简历，不要多个岗位使用同一份简历，简历上重点突出他们需要的能力，不要大杂烩（我就很吃这方面亏） boss直聘，实习僧，公司官网。。。。都可以去投 关于竞赛和成绩竞赛其实在面试中算是锦上添花，但是其实很多比赛面试官连听都没听过，他会让你去讲你们比赛都做了什么，如果你擅长讲故事的话，确实可以写上去加分。 当然一些硬核的比赛还是很加分的，比如什么ACM&#x2F;ICPC&#x2F;CTF&#x2F;超算大赛&#x2F;RM&#x2F;RC。。。。，但是这些一般也很难拿奖（） 至少我面试的很多公司对于比赛不是很重视（可能都是牛马岗） 关于成绩，只要不要太离谱，一般没事，GPA比较低的可以在简历上不写，GPA 3.5以上我认为都可以写上去，问题不大 写在最后人生是旷野，我在这里讲的都是我的眼光能看到的，但是我的眼光可能也是狭隘的，我上面的建议不一定适合所有人，每个人热爱的和适合的都不一样，还是希望大家能够根据自己的热爱去选择岗位，活出自己独一无二，多姿多彩的人生。 Any Question？QWQ","tags":[]},{"title":"mipi_csi_imx415","date":"2025-03-30T09:57:14.188Z","path":"2025/03/30/mipi_csi_imx415/","text":"泰山派移植IMX415摄像头CMOS摄像头整体的数据流向 image-20250311140607067 IMX415驱动代码框架","tags":[]},{"title":"MFly-Hardware","date":"2025-02-19T10:12:21.000Z","path":"2025/02/19/MFly-Hardware/","text":"飞行器硬件设计本文主要记录飞行器硬件设计的过程,以及一些问题记录. 本飞行器旨在作为一个低成本的实验平台完成相关算法和工程落地实践 飞行器硬件拓扑飞机整体硬件拓扑 飞控硬件拓扑 遥控器硬件拓扑 飞控SOC域硬件设计核心板部分核心板部分是使用som-rk3399核心板,如图所示: SOM-RK3399核心板俯视图 SOM-RK3399是友善电子团队设计的一款266-pin金手指形式高性能ARM计算机模块，它采用了瑞芯微64位六核SoC RK3399作为主处理器，标配2GB DDR3内存和16GB闪存，板载2x2 MIMO双天线WiFi模组，尺寸只有69.6x50mm，模块上带有独立的TypeC供电接口，以及USB-C显示接口，无需底板也可以单独使用。 SOM-RK3399计算模块具有丰富的外设和扩展接口，通过底板可连接使用4通道NVMe高速固态硬盘，读写速度高达1GB&#x2F;s; 它还可以扩展使用双MIPI宽动态摄像头，另外它还带有eDP显示接口，MIPI显示接口, 1路USB3.0, 2路USB2.0, 以及I2C, I2S, SPI, PWM, GPIO和串口等各种资源。 相关核心板硬件部分可以参考链接:https://wiki.friendlyelec.com/wiki/index.php/SOM-RK3399/zh 该核心板使用0.5mm Pitch 260-Pin Standard Type DDR4 SODIMM Socket卡槽, 参考型号为:https://www.te.com/usa-en/product-2309409-5.html 根据卡槽引脚定义可以绘制相关原理图: SOM-RK3399硬件引脚图 HDMI电路部分核心板中引出了HDMI接口的引脚,我们需要在底板上进行实现,其中HDMI引脚电路如图所示: 底板HDMI原理图 SD卡电路部分核心板引出了SDMMC0相关引脚,这部分引脚可以画SD卡模块的电路,下面是这部分的原理图: 底板SD卡模块原理图 RJ45网口模块核心板上有一个PHY芯片,引出以太网引脚,下方为RJ45模块原理图: RJ45模块原理图 USB网卡电路USB网卡使用的是BL-M8812EU2,打算使用这个芯片作为图传芯片使用,原理图如下,封装使用的是自己画的封装,存在部分小瑕疵,但是并不影响使用: USB网卡模块原理图 电源方案汇总注意电阻选择上，有些数值在绘制的时候需要使用叠加来凑数 12V -&gt; 5V方案使用MP2236GJ-Z芯片 datasheet 主要特点和典型电路如下: 支持3V-18V输入,6A输出,对于此方案下,12V输入,5V输出的要求,绘制原理图如下: 12V -&gt; 3.3V方案依旧使用MP2236GJ-Z芯片 datasheet设计方案同上，但是在buck电阻上存在数据差别 飞控传感器部分气压计ICP-20100datasheet中的典型电路： image-20250226201805401 飞控外设分配 image-20250227202626796 参考文档 SOM-RK3399文档 MP2236GJ-Z datasheet 附录1 芯片选择部分芯片选型原则： 有完整的芯片数据手册，有参考设计方案 最好有相应的封装库进行设计，但是如果使用lceda进行设计需要审核一下使用的封装是否正确 选择可以在电商平台买到的芯片进行设计 附录2 打板前CheckList 检查项 是否完成 备注 电源电阻是否已经完成凑数 - [ ] 图传网卡需要独立出一块小板 - [ ] MIPI屏幕在第一版上暂时取消 - [ ]","tags":[{"name":"硬件,四轴","slug":"硬件-四轴","permalink":"https://dailynobug.github.io/tags/%E7%A1%AC%E4%BB%B6-%E5%9B%9B%E8%BD%B4/"}]},{"title":"open-project","date":"2024-06-30T16:14:24.000Z","path":"2024/06/30/open-project/","text":"开源项目收集本文档收集一些有意思的开源项目： linenoiselinenoise 是一个轻量级、跨平台的 C 语言库，用于命令行输入的处理。该项目最初是由 Salvatore Sanfilippo (antirez) 创建的，以提供一个简单、高效的替代方案，取代 GNU Readline 和 libedit 库。linenoise 的设计目标是保持最小化的代码库，同时提供足够的功能以满足大多数命令行应用程序的需求。 特点 轻量级：linenoise 的代码非常简洁，仅包含几个文件，使其易于理解和维护。 跨平台：支持多种操作系统，包括 Linux、MacOS 和 Windows。 无依赖：不依赖于任何第三方库，仅使用标准 C 库函数。 Unicode 支持：能够正确处理多字节字符和 Unicode 字符。 历史记录管理：支持命令历史记录，可以方便地浏览和编辑之前输入的命令。 自动补全：提供简单的自动补全功能，方便用户快速输入命令。 主要功能 行编辑：支持基本的行编辑功能，如删除、插入、左右移动光标等。 历史记录：可以记录用户输入的历史命令，并在命令行中上下浏览历史记录。 自动补全：通过提供回调函数，可以实现命令的自动补全功能。 多行支持：能够正确处理和显示多行输入。 链接：https://github.com/antirez/linenoise taipyTaipy 是一个用于创建数据驱动应用程序的 Python 库。它旨在帮助开发者快速构建、部署和管理数据科学应用程序，简化了数据流的构建和用户界面的设计。Taipy 通过一组高效的工具和框架，提供了一种灵活且易于使用的方法来处理复杂的数据科学任务。 特点 易于使用：提供简洁的 API 和高层次的抽象，使得开发者能够快速上手，减少了编写样板代码的时间。 灵活性：允许开发者自定义数据流和用户界面，以满足特定的业务需求。 可视化：内置丰富的图表和可视化组件，使得数据展示和交互变得更加直观。 扩展性：支持集成第三方库和工具，能够扩展其功能以适应更多的数据科学场景。 高效性：优化了数据处理和流管理，确保应用程序在大数据环境下的高效运行。 主要组件Taipy 包含几个关键组件，每个组件都专注于特定的功能领域： Taipy Core：用于定义和管理数据流和任务调度的核心库。它帮助开发者设计数据处理管道，并确保任务按顺序执行。 Taipy GUI：用于创建交互式用户界面的工具包。它提供了多种图表和控件，使得数据展示更加生动。 Taipy Config：用于配置和管理应用程序设置的模块。它允许开发者灵活地定义和调整应用程序的行为。 Taipy REST：用于构建 RESTful API 接口，使得应用程序可以轻松地与其他系统或服务进行通信。 链接：https://github.com/Avaiga/taipy kcphttps://github.com/skywind3000/kcp 项目背景KCP 是一个高效、轻量级的可靠 UDP 协议库，由开发者 skywind3000 创建并维护。它旨在通过 UDP 提供比 TCP 更低延迟、更灵活的数据传输能力，尤其适合对实时性要求高的场景（如游戏、实时音视频传输等）。 核心特点 低延迟设计 通过 ARQ（自动重传请求） 机制实现可靠传输，但优化了重传策略，减少等待时间。 对比 TCP 的“延迟 ACK”和“拥塞控制”，KCP 允许用户自定义参数（如 RTO、窗口大小），以平衡延迟与吞吐量。 高效传输 支持 选择性重传（仅重传丢失的包），而非传统 TCP 的“全部重传”。 提供 快速重传 机制，通过重复 ACK 快速检测丢包。 轻量与跨平台 纯 C 实现，代码简洁（核心代码约 1,000 行），易于集成到各类项目中。 支持 Windows、Linux、macOS 及移动端，并可嵌入到 C&#x2F;C++、Go、Rust 等语言生态。 灵活配置 提供多种模式（如普通模式、极速模式），用户可根据场景调整参数（如 nodelay、interval、resend 等）。 适用场景 游戏开发：MOBA、FPS 等对延迟敏感的游戏。 实时通信：音视频流、直播、视频会议。 物联网（IoT）：弱网环境下的设备间通信。 P2P 网络：需要高效可靠传输的分布式系统。 性能对比在相同带宽下，KCP 的延迟通常比 TCP 低 30%-40%，尤其在网络波动较大时表现更优。例如，在 10% 丢包率下，KCP 的吞吐量仍能接近理论最大值。 使用方式 集成源码：直接包含 ikcp.h 和 ikcp.c 到项目中。 配置参数：根据场景调整模式与参数（如 ikcp_nodelay 开启极速模式）。 绑定 UDP Socket：通过回调函数与 UDP 结合，实现数据收发。","tags":[]},{"title":"hijack_mac","date":"2024-06-17T01:17:51.000Z","path":"2024/06/17/hijack_mac/","text":"mac地址欺骗系统调用劫持通过劫持系统调用，可以拦截和修改应用程序请求的硬件信息，如 MAC 地址。 使用 LD_PRELOAD 劫持 getifaddrs 系统调用 编写劫持库： 创建一个共享库，劫持 getifaddrs 系统调用以返回伪造的 MAC 地址。 1234567891011121314151617181920212223242526272829303132333435363738394041#define _GNU_SOURCE#include &lt;dlfcn.h&gt;#include &lt;ifaddrs.h&gt;#include &lt;netpacket/packet.h&gt;#include &lt;net/if.h&gt;#include &lt;stdio.h&gt;int getifaddrs(struct ifaddrs **ifap) &#123; // 获取原始的 getifaddrs 函数 int (*original_getifaddrs)(struct ifaddrs **); original_getifaddrs = dlsym(RTLD_NEXT, \"getifaddrs\"); // 调用原始 getifaddrs 函数 int result = original_getifaddrs(ifap); if (result != 0) &#123; return result; &#125; // 打印调试信息 printf(\"getifaddrs called\\n\"); // 遍历接口列表并修改 MAC 地址 struct ifaddrs *ifa = *ifap; while (ifa) &#123; if (ifa-&gt;ifa_addr &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family == AF_PACKET) &#123; struct sockaddr_ll *s = (struct sockaddr_ll *)ifa-&gt;ifa_addr; // 修改 MAC 地址 s-&gt;sll_addr[0] = 0x02; s-&gt;sll_addr[1] = 0x42; s-&gt;sll_addr[2] = 0xac; s-&gt;sll_addr[3] = 0x11; s-&gt;sll_addr[4] = 0x00; s-&gt;sll_addr[5] = 0x02; // 打印调试信息 printf(\"Modified MAC address for interface %s\\n\", ifa-&gt;ifa_name); &#125; ifa = ifa-&gt;ifa_next; &#125; return result;&#125; 编译共享库： 1gcc -shared -fPIC -o libspoof_mac.so spoof_mac.c -ldl 使用 LD_PRELOAD 运行目标程序： 1LD_PRELOAD=./libspoof_mac.so ./target_program 如果出现mac地址欺骗未成功，可以尝试劫持其他相关系统调用，例如 ioctl SIOCGIFHWADDR 是一个特定的 ioctl 请求码，用于获取网络接口的硬件地址（MAC 地址）。ioctl 是一个通用的输入&#x2F;输出控制接口，可以对设备文件进行各种操作，而 SIOCGIFHWADDR 则专门用于网络设备。 SIOCGIFHWADDR 的使用当一个程序想要获取某个网络接口的 MAC 地址时，会使用 ioctl 系统调用并传递 SIOCGIFHWADDR 请求码。这个请求码指示内核返回指定网络接口的硬件地址。 请求的结构在使用 SIOCGIFHWADDR 请求时，通常需要一个 struct ifreq 结构体作为参数。该结构体定义在 &lt;net/if.h&gt; 头文件中，主要包含网络接口的名称和相关信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define _GNU_SOURCE#include &lt;dlfcn.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;net/if.h&gt;#include &lt;netpacket/packet.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;// 定义劫持的 ioctl 函数int ioctl(int fd, unsigned long request, ...) &#123; static int (*original_ioctl)(int, unsigned long, ...); if (!original_ioctl) &#123; original_ioctl = dlsym(RTLD_NEXT, \"ioctl\"); &#125; va_list args; va_start(args, request); int ret; if (request == SIOCGIFHWADDR) &#123; struct ifreq *ifr = va_arg(args, struct ifreq *); ret = original_ioctl(fd, request, ifr); if (ret == 0) &#123; // 打印调试信息 printf(\"Intercepted SIOCGIFHWADDR for interface: %s\\n\", ifr-&gt;ifr_name); // 修改 MAC 地址 ifr-&gt;ifr_hwaddr.sa_data[0] = 0x02; ifr-&gt;ifr_hwaddr.sa_data[1] = 0x42; ifr-&gt;ifr_hwaddr.sa_data[2] = 0xac; ifr-&gt;ifr_hwaddr.sa_data[3] = 0x11; ifr-&gt;ifr_hwaddr.sa_data[4] = 0x00; ifr-&gt;ifr_hwaddr.sa_data[5] = 0x02; // 打印调试信息 printf(\"Modified MAC address for interface %s\\n\", ifr-&gt;ifr_name); &#125; &#125; else &#123; ret = original_ioctl(fd, request, va_arg(args, void *)); &#125; va_end(args); return ret;&#125;","tags":[]},{"title":"泰山派调试常用命令","date":"2024-06-17T01:17:51.000Z","path":"2024/06/17/泰山派调试常用命令/","text":"泰山派调试常用命令ubuntu下使用命令行连接wifi12345sudo iwlist scannmcli device wifi listnmcli device wifi connect &#123;ESSID&#125; password &#123;PASSWORD&#125;nmcli device wifi connect 404_2.4g password &quot;@404@404&quot;make modules_install INSTALL_MOD_PATH&#x3D;&lt;rootfs_path&gt; image-20250305184435807 image-20250305184444185 备忘录12345678910111213141516171819 v4l2-ctl --list-devicesv4l2-ctl --list-formats-ext --device=/dev/video0v4l2-ctl -d /dev/video0 -Lv4l2-ctl --verbose -d /dev/video0 --set-fmt-video=width=3840,height=2160,pixelformat='NV61' --stream-mmap=20 --set-selection=target=crop,flags=0,top=0,left=0,width=3840,height=2160 --set-ctrl analogue_gain=100 --stream-to=/tmp/out.yuvv4l2-ctl --verbose -d /dev/video1 --set-fmt-video=width=1920,height=1080,pixelformat='UYVY' --stream-mmap=20 --stream-to=/tmp/out.yuvffmpeg -f v4l2 -input_format nv12 -video_size 1920x1080 -i /dev/video0 -c:v libx264 -preset ultrafast output.mp4ffmpeg -f v4l2 -i /dev/video0 -pixel_format yuv422p -framerate 15 -video_size 800x600 -c:v copy -f mpegts udp://@:1234ffmpeg -f v4l2 -input_format nv12 -video_size 1920x1080 -i /dev/video8 -t 10 output.yuvffmpeg -f rawvideo -pixel_format yuv422p -video_size 3840x2160 -framerate 24 -i out.yuv -c:v libx264 output.mp4scp lsc@192.168.115.129:/home/lsc/project/Release/kernel/boot.img ./","tags":[]}]