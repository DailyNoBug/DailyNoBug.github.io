<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SCBLOG</title>
  <icon>https://www.gravatar.com/avatar/9f422c1be5ea2e238d8111cbc5a2a032</icon>
  
  <link href="https://dailynobug.github.io/atom.xml" rel="self"/>
  
  <link href="https://dailynobug.github.io/"/>
  <updated>2025-04-14T09:05:40.136Z</updated>
  <id>https://dailynobug.github.io/</id>
  
  <author>
    <name>black liu</name>
    <email>liusc0616@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mipi_csi_imx415</title>
    <link href="https://dailynobug.github.io/2025/04/14/mipi_csi_imx415/"/>
    <id>https://dailynobug.github.io/2025/04/14/mipi_csi_imx415/</id>
    <published>2025-04-14T09:05:40.136Z</published>
    <updated>2025-04-14T09:05:40.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泰山派移植IMX415摄像头"><a href="#泰山派移植IMX415摄像头" class="headerlink" title="泰山派移植IMX415摄像头"></a>泰山派移植IMX415摄像头</h1><h2 id="CMOS摄像头整体的数据流向"><a href="#CMOS摄像头整体的数据流向" class="headerlink" title="CMOS摄像头整体的数据流向"></a>CMOS摄像头整体的数据流向</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250311140607067.png" alt="image-20250311140607067" title="">                </div>                <div class="image-caption">image-20250311140607067</div>            </figure><h2 id="IMX415驱动代码框架"><a href="#IMX415驱动代码框架" class="headerlink" title="IMX415驱动代码框架"></a>IMX415驱动代码框架</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;泰山派移植IMX415摄像头&quot;&gt;&lt;a href=&quot;#泰山派移植IMX415摄像头&quot; class=&quot;headerlink&quot; title=&quot;泰山派移植IMX415摄像头&quot;&gt;&lt;/a&gt;泰山派移植IMX415摄像头&lt;/h1&gt;&lt;h2 id=&quot;CMOS摄像头整体的数据流向&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ELRS_RX&amp;TX</title>
    <link href="https://dailynobug.github.io/2025/04/13/ELRS_RX&amp;TX/"/>
    <id>https://dailynobug.github.io/2025/04/13/ELRS_RX&amp;TX/</id>
    <published>2025-04-13T09:17:51.000Z</published>
    <updated>2025-04-14T09:05:40.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELRS信号收发"><a href="#ELRS信号收发" class="headerlink" title="ELRS信号收发"></a>ELRS信号收发</h1><h2 id="ELRS介绍"><a href="#ELRS介绍" class="headerlink" title="ELRS介绍"></a>ELRS介绍</h2><p>ExpressLRS（简称 ELRS）是一个<strong>开源</strong>的、<strong>高性能</strong>的无线电控制（RC）链路系统。它主要用于遥控模型（如无人机、固定翼飞机、遥控车等），旨在提供<strong>长距离</strong>、<strong>低延迟</strong>、<strong>高刷新率</strong>和<strong>高抗干扰性</strong>的无线连接。</p><p><strong>核心特点：</strong></p><ol><li><strong>开源:</strong> 固件代码完全开放，由社区驱动开发和维护。</li><li><strong>高性能:</strong> 相较于许多传统 RC 协议，ELRS 提供更低的延迟（可达毫秒级）和更高的数据包刷新率（可达 1000Hz）。</li><li><strong>远距离:</strong> 基于 Semtech 的 LoRa（远距离）物理层调制技术（以及 2.4GHz 上的 FLRC），即使在较低功率下也能实现数公里甚至数十公里的控制距离。</li><li><strong>高抗干扰:</strong> 结合了 LoRa&#x2F;FLRC 调制和跳频技术（FHSS），在复杂的无线环境中具有更好的鲁棒性。</li><li><strong>成本效益:</strong> 通常基于 ESP32、ESP8285 或 STM32 等低成本微控制器和 Semtech SX127x (868&#x2F;915MHz) 或 SX128x (2.4GHz) 射频芯片构建。</li><li><strong>丰富功能:</strong> 支持完整的遥测回传、动态发射功率调整、无线固件更新等。</li></ol><h2 id="ELRS-实现原理"><a href="#ELRS-实现原理" class="headerlink" title="ELRS 实现原理"></a>ELRS 实现原理</h2><p>ELRS 的实现依赖于硬件（射频芯片+MCU）和软件（ELRS 固件）的结合。其核心原理可以概括为以下几点：</p><ol><li><strong>物理层调制 (PHY):</strong><ul><li>主要使用 <strong>LoRa</strong> 调制：这是一种扩频调制技术，通过牺牲一部分数据传输速率来换取极高的接收灵敏度（意味着可以接收到非常微弱的信号）和抗干扰能力，从而实现远距离通信。</li><li>在 2.4GHz 频段，ELRS 也支持 <strong>FLRC</strong> (Fast Long Range Communication) 调制，它能在保持较好距离和抗干扰性的同时，提供比 LoRa 更高的数据速率和更低的延迟。固件会根据配置（如数据包速率）智能选择使用 LoRa 还是 FLRC。</li></ul></li><li><strong>数据链路层:</strong><ul><li><strong>定制协议:</strong> ELRS 定义了自己的数据包结构，针对 RC 控制信号（通道数据）和遥测数据进行了优化，力求高效和低延迟。</li><li><strong>跳频扩频 (FHSS):</strong> 为了进一步抵抗干扰和提高链路的鲁棒性，ELRS 在多个预设的信道之间快速切换频率进行通信。发射机和接收机使用同步的跳频序列。</li><li><strong>绑定机制:</strong> 发射机（TX）和接收机（RX）通过一个用户设定的“绑定短语”（Binding Phrase）进行安全配对。只有拥有相同绑定短语的设备才能建立连接，防止被其他设备控制。</li><li><strong>同步:</strong> 发射机和接收机需要精确同步它们的时钟和跳频序列才能成功通信。</li></ul></li><li><strong>软件固件:</strong><ul><li>ELRS 固件运行在发射机和接收机模块的 MCU 上。</li><li><strong>发射端 (TX):</strong> 固件从遥控器（通过串行端口如 CRSF 协议）读取用户的控制输入，将其打包成 ELRS 格式，控制 SX12xx 芯片进行调制、跳频并发射。同时接收来自接收机的遥测数据并传回遥控器显示。</li><li><strong>接收端 (RX):</strong> 固件控制 SX12xx 芯片接收信号，进行解调和跳频同步。接收到有效数据包后，解包并将控制数据通过串行端口（通常是 CRSF 协议）发送给飞控或其他伺服设备。同时，它可以从飞控收集遥测数据，打包并发回给发射机。</li></ul></li></ol><h2 id="CRSF协议介绍"><a href="#CRSF协议介绍" class="headerlink" title="CRSF协议介绍"></a>CRSF协议介绍</h2><h3 id="什么是-CRSF-协议？"><a href="#什么是-CRSF-协议？" class="headerlink" title="什么是 CRSF 协议？"></a>什么是 CRSF 协议？</h3><p>CRSF (Crossfire Protocol) 是由 Team BlackSheep (TBS) 公司为其 Crossfire 远程无线电控制 (RC) 系统开发的一种<strong>双向串行通信协议</strong>。它主要用于在 RC 发射机（或其射频模块）与 RC 接收机（或飞行控制器）之间传输控制信号和遥测数据。</p><p>由于其高效、低延迟和强大的功能集，CRSF 已成为现代 RC 系统（包括 ExpressLRS、Tracer 等）和飞行控制器固件（如 Betaflight, INAV, ArduPilot）中广泛采用的事实标准。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li><strong>双向通信:</strong> 支持从发射机到接收机&#x2F;飞控的 RC 通道数据传输，以及从接收机&#x2F;飞控到发射机的遥测数据（如信号强度、电池电压、GPS 等）回传。</li><li><strong>串行传输:</strong> 通常通过 UART (通用异步收发传输器) 接口进行通信，物理连接简单。</li><li><strong>高效率:</strong> 采用紧凑的二进制数据帧格式，减少了传输开销。</li><li><strong>低延迟:</strong> 设计目标之一就是最小化控制链路的延迟。</li><li><strong>高数据包速率:</strong> 支持较高的更新频率，以匹配 ELRS 等高性能 RC 链路。</li><li><strong>可扩展性:</strong> 协议定义了多种帧类型，可以传输各种遥测信息，并支持设备发现、配置等高级功能。</li><li><strong>广泛支持:</strong> 被众多开源和商业 RC 产品及飞控固件支持。</li></ul><h3 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h3><p>CRSF 通信是主从式的，通常：</p><ol><li><strong>发射机&#x2F;TX 模块 -&gt; 接收机&#x2F;飞控:</strong><ul><li>发送 RC 通道数据（包含摇杆、开关等位置信息）。</li><li>发送设备查询 (Ping) 消息。</li><li>发送配置命令。</li></ul></li><li><strong>接收机&#x2F;飞控 -&gt; 发射机&#x2F;TX 模块:</strong><ul><li>响应设备查询，发送设备信息。</li><li>主动发送遥测数据帧，如：<ul><li>链路统计信息 (RSSI, LQ, SNR)</li><li>电池传感器信息 (电压, 电流, 容量)</li><li>GPS 位置信息</li><li>姿态信息</li><li>飞行模式</li><li>等等…</li></ul></li></ul></li></ol><h3 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h3><p>CRSF 使用二进制帧格式，其基本结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Device Address&gt; &lt;Frame Length&gt; &lt;Frame Type&gt; &lt;Payload&gt; &lt;CRC8&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>Device Address (1 byte):</strong> 帧的目标或来源设备地址（同步字节）。常见地址：<ul><li><code>0xC8</code>: 飞行控制器 (Flight Controller)</li><li><code>0xEA</code>: 无线电发射机 (Radio Transmitter)</li><li><code>0xEE</code>: 接收机 (Receiver)</li><li><code>0xEF</code>: TBS Core PNP Pro</li><li>… 其他地址用于不同设备</li></ul></li><li><strong>Frame Length (1 byte):</strong> <code>Frame Type</code> + <code>Payload</code> + <code>CRC8</code> 的总字节数。最大长度通常限制在 62 字节（总帧长 64 字节）。</li><li><strong>Frame Type (1 byte):</strong> 定义了 Payload 中包含的数据类型。</li><li><strong>Payload (Variable length):</strong> 实际的数据内容，其结构由 <code>Frame Type</code> 决定。</li><li><strong>CRC8 (1 byte):</strong> 循环冗余校验码，用于校验从 <code>Frame Type</code> 开始到 <code>Payload</code> 结束的数据完整性。通常使用 CRC-8-DVB-S2 多项式 (0xD5)。</li></ul><h3 id="常见帧类型示例"><a href="#常见帧类型示例" class="headerlink" title="常见帧类型示例"></a>常见帧类型示例</h3><ul><li><code>0x16</code>: <code>CRSF_FRAMETYPE_RC_CHANNELS_PACKED</code> - 包含压缩的 RC 通道数据（通常是 16 个通道，每个通道 11 位）。这是从发射机到接收机&#x2F;飞控最核心的数据帧。</li><li><code>0x14</code>: <code>CRSF_FRAMETYPE_LINK_STATISTICS</code> - 包含链路统计信息，如上行&#x2F;下行 RSSI、LQ (链路质量)、SNR (信噪比) 等。</li><li><code>0x08</code>: <code>CRSF_FRAMETYPE_BATTERY_SENSOR</code> - 包含电池信息，如电压 (mV)、电流 (cA)、已用容量 (mAh)。</li><li><code>0x02</code>: <code>CRSF_FRAMETYPE_GPS</code> - 包含 GPS 信息，如经度、纬度、地速、高度、卫星数等。</li><li><code>0x28</code>: <code>CRSF_FRAMETYPE_DEVICE_PING</code> - 设备查询帧。</li><li><code>0x29</code>: <code>CRSF_FRAMETYPE_DEVICE_INFO</code> - 设备信息响应帧，包含设备名称、硬件&#x2F;软件版本等。</li><li><code>0x07</code>: <code>CRSF_FRAMETYPE_ATTITUDE</code> - 包含姿态信息（俯仰、滚转、偏航角）。</li></ul><h3 id="物理层-UART"><a href="#物理层-UART" class="headerlink" title="物理层 (UART)"></a>物理层 (UART)</h3><ul><li><strong>接口:</strong> 标准 UART (TX, RX 引脚)。</li><li><strong>电平:</strong> 通常为 3.3V TTL 电平。</li><li><strong>参数:</strong> 8 数据位, 无校验位, 1 停止位 (8N1)。</li><li><strong>波特率:</strong> 常见的波特率包括 115200 bps, 400000 bps, 420000 bps 等。ELRS 通常使用较高的波特率（如 400k 或更高）以匹配其高数据包速率。发射机和接收机&#x2F;飞控必须配置为使用相同的波特率。</li></ul><h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>发射端和接收端的硬件设计在核心连接上类似，主要区别在于与外部设备（遥控器或飞控）的接口。</p><h3 id="2-1-通用硬件要求-TX-和-RX"><a href="#2-1-通用硬件要求-TX-和-RX" class="headerlink" title="2.1. 通用硬件要求 (TX 和 RX)"></a>2.1. 通用硬件要求 (TX 和 RX)</h3><ol><li><strong>主控 MCU 选择:</strong><ul><li><strong>推荐:</strong> ESP32 系列 (因其性能、成本和 ELRS 社区广泛支持)。STM32 系列 (如 STM32F1, F4 等) 也是可选方案。</li><li><strong>要求:</strong><ul><li>高速 SPI 接口 (数据手册建议 &lt;&#x3D; 10MHz, CPOL&#x3D;0, CPHA&#x3D;0)。</li><li>足够的 GPIO 引脚用于连接模块的控制线 (NSS, RST, BUSY, DIO1, DIO2, DIO3, TXEN, RXEN)。</li><li>至少一个 UART 接口用于与遥控器&#x2F;飞控通信 (通常使用 CRSF 协议) 或用于调试&#x2F;烧录。</li><li>足够的 Flash 和 RAM 以运行 ELRS 固件。</li></ul></li></ul></li><li><strong>VG2392S240X0M2 模块与 MCU 连接:</strong><ul><li><strong>电源 (VCC, GND):</strong><ul><li>提供稳定的 3.1V 至 3.6V 电源，<strong>典型值为 3.3V</strong> (手册 Page 4)。</li><li>强烈建议使用低噪声 LDO 为模块供电 (手册 Page 8)。</li><li>在模块 VCC 引脚附近放置滤波电容，如 100nF 和 10uF (手册 Page 7 电路图示例)。</li><li>确保良好的接地，将模块的 GND 引脚 (Pin 2, 15) 连接到 MCU 的地。</li></ul></li><li><strong>SPI 接口:</strong><ul><li>MCU <code>MOSI</code> -&gt; 模块 <code>MOSI</code> (Pin 6)</li><li>MCU <code>MISO</code> &lt;- 模块 <code>MISO</code> (Pin 7)</li><li>MCU <code>SCK</code> -&gt; 模块 <code>SCK</code> (Pin 4)</li><li>MCU <code>NSS</code> -&gt; 模块 <code>NSS</code> (Pin 3)</li></ul></li><li><strong>控制引脚:</strong><ul><li>MCU <code>GPIO</code> -&gt; 模块 <code>RST</code> (Pin 8, 低电平有效复位)</li><li>MCU <code>GPIO</code> &lt;- 模块 <code>BUSY</code> (Pin 9, 高电平表示模块忙)</li><li>MCU <code>GPIO</code> (中断输入) &lt;- 模块 <code>DIO1</code> (Pin 10, 用于 TxDone, RxDone 等中断)</li><li>MCU <code>GPIO</code> &lt;-&gt; 模块 <code>DIO2</code> (Pin 11, 可配置功能，ELRS 可能用于天线切换或其他)</li><li>MCU <code>GPIO</code> &lt;-&gt; 模块 <code>DIO3</code> (Pin 12, 可配置功能)</li></ul></li><li><strong>PA&#x2F;LNA 控制 (关键):</strong><ul><li>MCU <code>GPIO</code> -&gt; 模块 <code>TXEN</code> (Pin 13, 发射使能，高电平有效)</li><li>MCU <code>GPIO</code> -&gt; 模块 <code>RXEN</code> (Pin 14, 接收使能，高电平有效)</li><li><strong>注意:</strong> ELRS 固件必须根据当前操作（发射、接收、空闲&#x2F;休眠）精确控制这两个引脚的电平 (逻辑见手册 Page 13)。</li></ul></li></ul></li><li><strong>天线:</strong><ul><li><strong>选择:</strong> 模块提供三种天线连接方式：板载 PCB 天线 (默认)、IPEX-1 座、邮票孔半孔 (手册 Page 5)。</li><li><strong>跳线电阻:</strong> 如果不使用默认的板载 PCB 天线，需要根据手册 Page 9 的图示修改模块内部的 0 欧姆跳线电阻，将信号路径切换到 IPEX 座或邮票孔 ANT 引脚 (Pin 1)。</li><li><strong>外部天线:</strong> 若使用外部天线 (通过 IPEX 或邮票孔)，需选择 2.4GHz 频段、50 欧姆阻抗的天线。</li><li><strong>RF 走线 (若使用邮票孔):</strong> 从模块 ANT 引脚 (Pin 1) 到天线连接器的 PCB 走线应尽可能短、直，保持 50 欧姆特性阻抗。遵循手册 Page 9-10 的 RF 走线和拐弯建议。避免直角拐弯，推荐圆弧或 45 度角。</li><li><strong>布局:</strong> 确保天线（尤其是板载 PCB 天线）远离金属外壳、电池、大型元器件和 PCB 接地铜皮覆盖区域，以保证辐射效率 (手册 Page 11)。</li></ul></li></ol><h3 id="2-2-发射端-TX-特定设计"><a href="#2-2-发射端-TX-特定设计" class="headerlink" title="2.2. 发射端 (TX) 特定设计"></a>2.2. 发射端 (TX) 特定设计</h3><ul><li><strong>与遥控器接口:</strong> 通常通过 UART 连接到遥控器主板，使用 CRSF 协议传输通道数据和接收遥测数据。</li><li><strong>用户接口 (可选):</strong> 可添加按钮用于绑定或功能切换，添加 LED 指示灯显示电源、连接状态、遥测状态等。</li></ul><h3 id="2-3-接收端-RX-特定设计"><a href="#2-3-接收端-RX-特定设计" class="headerlink" title="2.3. 接收端 (RX) 特定设计"></a>2.3. 接收端 (RX) 特定设计</h3><ul><li><strong>与飞控接口:</strong> 通常通过 UART 连接到飞控，使用 CRSF 协议发送控制指令和接收遥测数据请求。</li><li><strong>用户接口 (可选):</strong> 可添加 LED 指示灯显示电源、连接状态、绑定状态等。</li></ul><h2 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><p>软件设计的核心是配置和编译适用于该硬件组合的 ELRS 固件。</p><ol><li><strong>获取固件:</strong><ul><li>使用官方 <strong>ExpressLRS Configurator</strong> 工具，这是最简单的方式。</li><li>或者从 ExpressLRS GitHub 仓库 (<a href="https://github.com/ExpressLRS/ExpressLRS" target="_blank" rel="noopener">https://github.com/ExpressLRS/ExpressLRS</a>) 获取源码，使用 PlatformIO 进行编译。</li></ul></li><li><strong>硬件目标 (Target) 配置:</strong><ul><li><strong>关键步骤:</strong> 需要在 ELRS Configurator 或 PlatformIO 环境中选择或定义一个硬件目标，该目标必须与您使用的 MCU 以及 VG2392S240X0M2 模块的引脚连接相匹配。</li><li><strong>PA&#x2F;LNA 控制:</strong> 由于此模块带有外部 PA&#x2F;LNA，<strong>必须</strong>选择一个支持 <code>TXEN</code> 和 <code>RXEN</code> 引脚控制的 ELRS 硬件目标配置。如果官方没有完全匹配的预设目标，您可能需要：<ul><li>查找基于相同 MCU 且使用类似 PA&#x2F;LNA 控制方式 (如 RadioMaster Ranger Micro 2.4GHz 等) 的目标作为参考。</li><li>或者，在 PlatformIO 中创建自定义硬件布局 (Hardware Layout)，在对应的 <code>.ini</code> 文件或 <code>user_defines.txt</code> &#x2F; <code>hardware.h</code> 中正确定义 <code>RADIO_TXEN_PIN</code> 和 <code>RADIO_RXEN_PIN</code> 所连接的 MCU GPIO 引脚号。</li></ul></li><li><strong>引脚定义:</strong> 确保配置文件中定义的 SPI (MOSI, MISO, SCK, NSS)、RST、BUSY、DIO1 (IRQ) 引脚与硬件连接一致。DIO2&#x2F;DIO3 根据 ELRS 目标是否使用它们来决定是否需要定义。</li></ul></li><li><strong>关键固件配置参数:</strong><ul><li><strong>Regulatory Domain:</strong> 选择 <code>ISM_2400</code>。</li><li><strong>Binding Phrase:</strong> 为 TX 和 RX 设置相同的绑定短语。</li><li><strong>TX&#x2F;RX Role:</strong> 分别为发射端和接收端固件选择 <code>TX</code> 或 <code>RX</code>。</li><li><strong>Radio Output Power (重要!):</strong><ul><li>模块手册 (Page 4, 12) 指出，当 SX1281 内部输出设置为 0dBm 时，模块最终输出可达 27dBm。</li><li>因此，在 ELRS 固件配置中，<strong>不能</strong>直接设置目标输出功率为 27dBm。您需要配置 ELRS，使其驱动 SX1281 芯片输出较低的功率（例如 0dBm 或根据实际 PA 增益计算得出的值）。</li><li>具体的配置方式依赖于所选的 ELRS 硬件目标。通常在硬件配置文件 (<code>hardware.h</code> 或类似文件) 中会有功率相关的定义，需要确保这些定义与模块的 PA 增益相匹配，以避免损坏 PA 或输出功率超标。<strong>务必仔细查阅所选 ELRS 目标关于功率设置的说明，或在自定义目标时正确设置功率表。</strong> 手册建议 SX1281 输出不要超过 5dBm (Page 12)。</li></ul></li><li><strong>Packet Rate &#x2F; Telemetry Ratio:</strong> 根据需求选择合适的速率和遥测比率。</li></ul></li><li><strong>编译与烧录:</strong><ul><li>使用 ELRS Configurator 或 PlatformIO 编译固件。</li><li>通过 USB 转串口工具或其他烧录方式将编译好的固件分别烧录到 TX 和 RX 模块的 MCU 中。</li></ul></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://www.expresslrs.org/hardware/hardware-selection/" target="_blank" rel="noopener">ELRS官方网站</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ELRS信号收发&quot;&gt;&lt;a href=&quot;#ELRS信号收发&quot; class=&quot;headerlink&quot; title=&quot;ELRS信号收发&quot;&gt;&lt;/a&gt;ELRS信号收发&lt;/h1&gt;&lt;h2 id=&quot;ELRS介绍&quot;&gt;&lt;a href=&quot;#ELRS介绍&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>pt-questions</title>
    <link href="https://dailynobug.github.io/2025/03/30/pt_questions/"/>
    <id>https://dailynobug.github.io/2025/03/30/pt_questions/</id>
    <published>2025-03-30T15:14:24.000Z</published>
    <updated>2025-04-14T09:05:40.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PT问题解答-20250330"><a href="#PT问题解答-20250330" class="headerlink" title="PT问题解答-20250330"></a>PT问题解答-20250330</h1><h2 id="实训相关"><a href="#实训相关" class="headerlink" title="实训相关"></a>实训相关</h2><p>实训可以用竞赛顶替，任何竞赛都可以，只是分数高低的问题，如果不卷分数的话直接随便拿个奖顶掉就行，如果没奖甚至可以用银杏果或者大创项目抵掉</p><p>关于实训是否有价值，我个人认为学校合作的企业实训没有任何价值，有这时间不如自己搞点项目玩</p><p>应抵尽抵</p><h2 id="实习相关"><a href="#实习相关" class="headerlink" title="实习相关"></a>实习相关</h2><p>因为个人经历问题，这里描述的都是企业实习相关的内容</p><h3 id="方向方面"><a href="#方向方面" class="headerlink" title="方向方面"></a>方向方面</h3><p>当前就业方向很多，很宽泛，很难说谁适合什么方向，但是如果是本科生就业，<strong>技术岗位一般</strong>集中于下面几个方向：</p><ol><li>前端开发</li><li>后端开发</li><li>嵌入式开发</li><li>测试岗位</li><li>移动端开发（有时并入前后端开发）</li><li>系统架构方向</li><li>运维开发方向（可能有些岗位会涉及到AI infra）</li></ol><p>同时也有一些小众一些但是<strong>难度较高</strong>的技术岗位方向：</p><ol><li>网络安全方向（CTF大手子？）</li><li>量化金融方向（一般侧重于高性能计算）</li><li>AI方向（本科就业可能会比较难）</li><li>硬件电子方向（本科就业纯牛马，不推荐）</li></ol><p>除了技术之外还有一些非技术或者单纯和技术沾边的方向：</p><ol><li>产品经理（吃经验，想往这个方向走最好实习就冲）</li><li>部门HR？（这我还真没了解过）</li><li>FAE（Field Application Engineer 现场应用工程师），不好评，分企业，有的纯牛马</li><li>销售？</li><li>…….</li></ol><h3 id="能力方面"><a href="#能力方面" class="headerlink" title="能力方面"></a>能力方面</h3><p>不同方向的岗位需要不同的能力，具体的能力要求可以参考你感兴趣的岗位JD要求。可以去翻翻招聘软件或者你感兴趣的公司的官网，找到你感兴趣的岗位，看看有什么要求，一般JD要求的能力会比较杂，你精通其中的一两个其实就可以去投递，大胆开投，大不了被挂。</p><p>能力不求面面俱到，但求专精。</p><p>这里列举一些嵌入式软件开发能力（介绍的算是比较全面了，并不一定全部掌握，下面全是口胡）：</p><ol><li>熟练使用C&#x2F;C++，CMake ，Makefile，shell ， python等语言</li><li>熟练掌握STM32&#x2F;GD32&#x2F;各类MCU的外设驱动开发（SPI，IIC，UART，DMA，CAN，USB），熟悉传感器开发流程</li><li>熟悉RTOS移植和内核工作原理，熟练使用至少一种RTOS</li><li>能够看懂原理图，PCB图，会使用示波器，逻辑分析仪，频谱仪等测试设备</li><li>熟练掌握常用的嵌入式开发环境的搭建和使用，熟悉linux系统的使用（看起来很容易，但是确实是嵌入式开发当中很重要的能力）</li><li>linux kernel移植，功能裁切，linux驱动开发，uboot kernel rootfs及烧录，启动，调试。</li><li>还有很多，比如传感器方面的驱动开发，标定校准；系统调试调优，负载优化；摄像头，嵌入式音视频开发，Camera 3A算法开发，编解码开发。。。。</li></ol><h3 id="岗位方面"><a href="#岗位方面" class="headerlink" title="岗位方面"></a>岗位方面</h3><p>可以根据自己的兴趣进行选择，可以广撒网多捞鱼的去选择，不要在一棵树上吊死，不要局限于一个方向，也不一定全投开发</p><p>不同的岗位可以针对性的优化自己的简历，不要多个岗位使用同一份简历，简历上重点突出他们需要的能力，不要大杂烩（<del>我就很吃这方面亏</del>）</p><p>boss直聘，实习僧，公司官网。。。。都可以去投</p><h3 id="关于竞赛和成绩"><a href="#关于竞赛和成绩" class="headerlink" title="关于竞赛和成绩"></a>关于竞赛和成绩</h3><p>竞赛其实在面试中算是锦上添花，但是其实很多比赛面试官连听都没听过，他会让你去讲你们比赛都做了什么，如果你擅长讲故事的话，确实可以写上去加分。</p><p>当然一些硬核的比赛还是很加分的，比如什么ACM&#x2F;ICPC&#x2F;CTF&#x2F;超算大赛&#x2F;RM&#x2F;RC。。。。，但是这些一般也很难拿奖（）</p><p>至少我面试的很多公司对于比赛不是很重视（<del>可能都是牛马岗</del>）</p><p>关于成绩，只要不要太离谱，一般没事，GPA比较低的可以在简历上不写，GPA 3.5以上我认为都可以写上去，问题不大</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>人生是旷野，我在这里讲的都是我的眼光能看到的，但是我的眼光可能也是狭隘的，我上面的建议不一定适合所有人，每个人热爱的和适合的都不一样，还是希望大家能够根据自己的热爱去选择岗位，活出自己独一无二，多姿多彩的人生。</p><h2 id="Any-Question？"><a href="#Any-Question？" class="headerlink" title="Any Question？"></a>Any Question？</h2><p>QWQ</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PT问题解答-20250330&quot;&gt;&lt;a href=&quot;#PT问题解答-20250330&quot; class=&quot;headerlink&quot; title=&quot;PT问题解答-20250330&quot;&gt;&lt;/a&gt;PT问题解答-20250330&lt;/h1&gt;&lt;h2 id=&quot;实训相关&quot;&gt;&lt;a href</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MFly-Hardware</title>
    <link href="https://dailynobug.github.io/2025/02/19/MFly-Hardware/"/>
    <id>https://dailynobug.github.io/2025/02/19/MFly-Hardware/</id>
    <published>2025-02-19T10:12:21.000Z</published>
    <updated>2025-04-14T09:05:40.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="飞行器硬件设计"><a href="#飞行器硬件设计" class="headerlink" title="飞行器硬件设计"></a>飞行器硬件设计</h1><p>本文主要记录飞行器硬件设计的过程,以及一些问题记录.</p><p>本飞行器旨在作为一个低成本的实验平台完成相关算法和工程落地实践</p><h2 id="飞行器硬件拓扑"><a href="#飞行器硬件拓扑" class="headerlink" title="飞行器硬件拓扑"></a>飞行器硬件拓扑</h2><h3 id="飞机整体硬件拓扑"><a href="#飞机整体硬件拓扑" class="headerlink" title="飞机整体硬件拓扑"></a>飞机整体硬件拓扑</h3><img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/%E9%A3%9E%E8%A1%8C%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.drawio.png" alt="img" style="zoom: 80%;" /><h3 id="飞控硬件拓扑"><a href="#飞控硬件拓扑" class="headerlink" title="飞控硬件拓扑"></a>飞控硬件拓扑</h3><img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/4-1%E9%A3%9E%E6%8E%A7%E7%BB%93%E6%9E%84%E5%9B%BE.drawio.png" alt="img" style="zoom:80%;" /><h3 id="遥控器硬件拓扑"><a href="#遥控器硬件拓扑" class="headerlink" title="遥控器硬件拓扑"></a>遥控器硬件拓扑</h3><img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/%E9%81%A5%E6%8E%A7%E5%99%A8%E7%BB%93%E6%9E%84.drawio.png" alt="img" style="zoom:80%;" /><h2 id="飞控SOC域硬件设计"><a href="#飞控SOC域硬件设计" class="headerlink" title="飞控SOC域硬件设计"></a>飞控SOC域硬件设计</h2><h3 id="核心板部分"><a href="#核心板部分" class="headerlink" title="核心板部分"></a>核心板部分</h3><p>核心板部分是使用som-rk3399核心板,如图所示:</p><img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250219155216587.png" alt="image-20250219155216587" style="zoom: 50%;" /><center><p>SOM-RK3399核心板俯视图<p/><center/><ul><li><p>SOM-RK3399是友善电子团队设计的一款266-pin金手指形式高性能ARM计算机模块，它采用了瑞芯微64位六核SoC RK3399作为主处理器，标配2GB DDR3内存和16GB闪存，板载2x2 MIMO双天线WiFi模组，尺寸只有69.6x50mm，模块上带有独立的TypeC供电接口，以及USB-C显示接口，无需底板也可以单独使用。</p></li><li><p>SOM-RK3399计算模块具有丰富的外设和扩展接口，通过底板可连接使用4通道NVMe高速固态硬盘，读写速度高达1GB&#x2F;s; 它还可以扩展使用双MIPI宽动态摄像头，另外它还带有eDP显示接口，MIPI显示接口, 1路USB3.0, 2路USB2.0, 以及I2C, I2S, SPI, PWM, GPIO和串口等各种资源。</p></li></ul><p>相关核心板硬件部分可以参考链接:<a href="https://wiki.friendlyelec.com/wiki/index.php/SOM-RK3399/zh" target="_blank" rel="noopener">https://wiki.friendlyelec.com/wiki/index.php/SOM-RK3399/zh</a></p><p>该核心板使用0.5mm Pitch 260-Pin <strong>Standard Type</strong> DDR4 SODIMM Socket卡槽,</p><p>参考型号为:<a href="https://www.te.com/usa-en/product-2309409-5.html" target="_blank" rel="noopener">https://www.te.com/usa-en/product-2309409-5.html</a></p><p>根据卡槽引脚定义可以绘制相关原理图:</p><center class="half">    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250219155533770.png" width="300"/>    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250219155554870.png" width="300"/></center><center><p>SOM-RK3399硬件引脚图<p/><center/><h3 id="HDMI电路部分"><a href="#HDMI电路部分" class="headerlink" title="HDMI电路部分"></a>HDMI电路部分</h3><p>核心板中引出了HDMI接口的引脚,我们需要在底板上进行实现,其中HDMI引脚电路如图所示:</p><center class="half">    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/20250219162624.png" width="300"/>    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/20250219162719.png" width="300"/>    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/20250219162747.png" width="300"/></center><center>    <p>        底板HDMI原理图    </p></center><h3 id="SD卡电路部分"><a href="#SD卡电路部分" class="headerlink" title="SD卡电路部分"></a>SD卡电路部分</h3><p>核心板引出了<code>SDMMC0</code>相关引脚,这部分引脚可以画SD卡模块的电路,下面是这部分的原理图:</p><center class="half">    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250219163109553.png" alt="image-20250219163109553" width="300"/>    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/20250219163351.png" width="300"/></center><center>    <p>        底板SD卡模块原理图    </p></center><h3 id="RJ45网口模块"><a href="#RJ45网口模块" class="headerlink" title="RJ45网口模块"></a>RJ45网口模块</h3><p>核心板上有一个PHY芯片,引出以太网引脚,下方为RJ45模块原理图:</p><center>    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/20250219164043.png" width="300">    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/20250219164124.png" width="300"></center><center>    <p>        RJ45模块原理图    </p></center><h3 id="USB网卡电路"><a href="#USB网卡电路" class="headerlink" title="USB网卡电路"></a>USB网卡电路</h3><p>USB网卡使用的是<code>BL-M8812EU2</code>,打算使用这个芯片作为图传芯片使用,原理图如下,封装使用的是自己画的封装,存在部分小瑕疵,但是并不影响使用:</p><center>    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/20250219164653.png" width="300">    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/20250219164755.png" width="300">    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/20250219164854.png" width="300"></center><center>    <p>USB网卡模块原理图</p></center><h2 id="电源方案汇总"><a href="#电源方案汇总" class="headerlink" title="电源方案汇总"></a>电源方案汇总</h2><p><strong>注意电阻选择上，有些数值在绘制的时候需要使用叠加来凑数</strong></p><h3 id="12V-5V方案"><a href="#12V-5V方案" class="headerlink" title="12V -&gt; 5V方案"></a>12V -&gt; 5V方案</h3><p>使用<strong>MP2236GJ-Z</strong>芯片 <a href="https://www.monolithicpower.com/en/documentview/productdocument/index/version/2/document_type/Datasheet/lang/en/sku/MP2236" target="_blank" rel="noopener">datasheet</a></p><p>主要特点和典型电路如下:</p><img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250219162207918.png" alt="image-20250219162207918" style="zoom: 67%;" /><p>支持3V-18V输入,6A输出,对于此方案下,12V输入,5V输出的要求,绘制原理图如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250219162328789.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="12V-3-3V方案"><a href="#12V-3-3V方案" class="headerlink" title="12V -&gt; 3.3V方案"></a>12V -&gt; 3.3V方案</h3><p>依旧使用<strong>MP2236GJ-Z</strong>芯片 <a href="https://www.monolithicpower.com/en/documentview/productdocument/index/version/2/document_type/Datasheet/lang/en/sku/MP2236" target="_blank" rel="noopener">datasheet</a>设计方案同上，但是在buck电阻上存在数据差别</p><h2 id="飞控传感器部分"><a href="#飞控传感器部分" class="headerlink" title="飞控传感器部分"></a>飞控传感器部分</h2><h3 id="气压计ICP-20100"><a href="#气压计ICP-20100" class="headerlink" title="气压计ICP-20100"></a>气压计ICP-20100</h3><p>datasheet中的典型电路：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250226201805401.png" alt="image-20250226201805401" title="">                </div>                <div class="image-caption">image-20250226201805401</div>            </figure><h2 id="飞控外设分配"><a href="#飞控外设分配" class="headerlink" title="飞控外设分配"></a>飞控外设分配</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250227202626796.png" alt="image-20250227202626796" title="">                </div>                <div class="image-caption">image-20250227202626796</div>            </figure><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://wiki.friendlyelec.com/wiki/index.php/SOM-RK3399/zh" target="_blank" rel="noopener">SOM-RK3399文档</a></li><li><a href="https://www.monolithicpower.com/en/documentview/productdocument/index/version/2/document_type/Datasheet/lang/en/sku/MP2236" target="_blank" rel="noopener">MP2236GJ-Z datasheet</a></li><li></li></ol><h2 id="附录1-芯片选择部分"><a href="#附录1-芯片选择部分" class="headerlink" title="附录1 芯片选择部分"></a>附录1 芯片选择部分</h2><p>芯片选型原则：</p><ol><li>有完整的芯片数据手册，有参考设计方案</li><li>最好有相应的封装库进行设计，但是如果使用lceda进行设计需要审核一下使用的封装是否正确</li><li>选择可以在电商平台买到的芯片进行设计</li></ol><h2 id="附录2-打板前CheckList"><a href="#附录2-打板前CheckList" class="headerlink" title="附录2 打板前CheckList"></a>附录2 打板前CheckList</h2><table><thead><tr><th>检查项</th><th>是否完成</th><th>备注</th></tr></thead><tbody><tr><td>电源电阻是否已经完成凑数</td><td>- [ ]</td><td></td></tr><tr><td>图传网卡需要独立出一块小板</td><td>- [ ]</td><td></td></tr><tr><td>MIPI屏幕在第一版上暂时取消</td><td>- [ ]</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;飞行器硬件设计&quot;&gt;&lt;a href=&quot;#飞行器硬件设计&quot; class=&quot;headerlink&quot; title=&quot;飞行器硬件设计&quot;&gt;&lt;/a&gt;飞行器硬件设计&lt;/h1&gt;&lt;p&gt;本文主要记录飞行器硬件设计的过程,以及一些问题记录.&lt;/p&gt;
&lt;p&gt;本飞行器旨在作为一个低成本的实验</summary>
      
    
    
    
    
    <category term="硬件,四轴" scheme="https://dailynobug.github.io/tags/%E7%A1%AC%E4%BB%B6-%E5%9B%9B%E8%BD%B4/"/>
    
  </entry>
  
  <entry>
    <title>open-project</title>
    <link href="https://dailynobug.github.io/2024/06/30/open-project/"/>
    <id>https://dailynobug.github.io/2024/06/30/open-project/</id>
    <published>2024-06-30T16:14:24.000Z</published>
    <updated>2025-04-14T09:05:40.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开源项目收集"><a href="#开源项目收集" class="headerlink" title="开源项目收集"></a>开源项目收集</h1><p>本文档收集一些有意思的开源项目：</p><h2 id="linenoise"><a href="#linenoise" class="headerlink" title="linenoise"></a><a href="https://github.com/antirez/linenoise" target="_blank" rel="noopener">linenoise</a></h2><p>linenoise 是一个轻量级、跨平台的 C 语言库，用于命令行输入的处理。该项目最初是由 Salvatore Sanfilippo (antirez) 创建的，以提供一个简单、高效的替代方案，取代 GNU Readline 和 libedit 库。linenoise 的设计目标是保持最小化的代码库，同时提供足够的功能以满足大多数命令行应用程序的需求。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>轻量级</strong>：linenoise 的代码非常简洁，仅包含几个文件，使其易于理解和维护。</li><li><strong>跨平台</strong>：支持多种操作系统，包括 Linux、MacOS 和 Windows。</li><li><strong>无依赖</strong>：不依赖于任何第三方库，仅使用标准 C 库函数。</li><li><strong>Unicode 支持</strong>：能够正确处理多字节字符和 Unicode 字符。</li><li><strong>历史记录管理</strong>：支持命令历史记录，可以方便地浏览和编辑之前输入的命令。</li><li><strong>自动补全</strong>：提供简单的自动补全功能，方便用户快速输入命令。</li></ol><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li><strong>行编辑</strong>：支持基本的行编辑功能，如删除、插入、左右移动光标等。</li><li><strong>历史记录</strong>：可以记录用户输入的历史命令，并在命令行中上下浏览历史记录。</li><li><strong>自动补全</strong>：通过提供回调函数，可以实现命令的自动补全功能。</li><li><strong>多行支持</strong>：能够正确处理和显示多行输入。</li></ul><p>链接：<a href="https://github.com/antirez/linenoise" target="_blank" rel="noopener">https://github.com/antirez/linenoise</a></p><h2 id="taipy"><a href="#taipy" class="headerlink" title="taipy"></a>taipy</h2><p>Taipy 是一个用于创建数据驱动应用程序的 Python 库。它旨在帮助开发者快速构建、部署和管理数据科学应用程序，简化了数据流的构建和用户界面的设计。Taipy 通过一组高效的工具和框架，提供了一种灵活且易于使用的方法来处理复杂的数据科学任务。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>易于使用</strong>：提供简洁的 API 和高层次的抽象，使得开发者能够快速上手，减少了编写样板代码的时间。</li><li><strong>灵活性</strong>：允许开发者自定义数据流和用户界面，以满足特定的业务需求。</li><li><strong>可视化</strong>：内置丰富的图表和可视化组件，使得数据展示和交互变得更加直观。</li><li><strong>扩展性</strong>：支持集成第三方库和工具，能够扩展其功能以适应更多的数据科学场景。</li><li><strong>高效性</strong>：优化了数据处理和流管理，确保应用程序在大数据环境下的高效运行。</li></ol><h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><p>Taipy 包含几个关键组件，每个组件都专注于特定的功能领域：</p><ol><li><strong>Taipy Core</strong>：用于定义和管理数据流和任务调度的核心库。它帮助开发者设计数据处理管道，并确保任务按顺序执行。</li><li><strong>Taipy GUI</strong>：用于创建交互式用户界面的工具包。它提供了多种图表和控件，使得数据展示更加生动。</li><li><strong>Taipy Config</strong>：用于配置和管理应用程序设置的模块。它允许开发者灵活地定义和调整应用程序的行为。</li><li><strong>Taipy REST</strong>：用于构建 RESTful API 接口，使得应用程序可以轻松地与其他系统或服务进行通信。</li></ol><p>链接：<a href="https://github.com/Avaiga/taipy" target="_blank" rel="noopener">https://github.com/Avaiga/taipy</a></p><h2 id="kcp"><a href="#kcp" class="headerlink" title="kcp"></a>kcp</h2><p><a href="https://github.com/skywind3000/kcp" target="_blank" rel="noopener">https://github.com/skywind3000/kcp</a></p><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p><strong>KCP</strong> 是一个高效、轻量级的可靠 UDP 协议库，由开发者 <strong>skywind3000</strong> 创建并维护。它旨在通过 UDP 提供比 TCP 更低延迟、更灵活的数据传输能力，尤其适合对实时性要求高的场景（如游戏、实时音视频传输等）。</p><h3 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h3><ol><li><strong>低延迟设计</strong><ul><li>通过 <strong>ARQ（自动重传请求）</strong> 机制实现可靠传输，但优化了重传策略，减少等待时间。</li><li>对比 TCP 的“延迟 ACK”和“拥塞控制”，KCP 允许用户自定义参数（如 RTO、窗口大小），以平衡延迟与吞吐量。</li></ul></li><li><strong>高效传输</strong><ul><li>支持 <strong>选择性重传</strong>（仅重传丢失的包），而非传统 TCP 的“全部重传”。</li><li>提供 <strong>快速重传</strong> 机制，通过重复 ACK 快速检测丢包。</li></ul></li><li><strong>轻量与跨平台</strong><ul><li>纯 C 实现，代码简洁（核心代码约 1,000 行），易于集成到各类项目中。</li><li>支持 Windows、Linux、macOS 及移动端，并可嵌入到 C&#x2F;C++、Go、Rust 等语言生态。</li></ul></li><li><strong>灵活配置</strong><ul><li>提供多种模式（如普通模式、极速模式），用户可根据场景调整参数（如 <code>nodelay</code>、<code>interval</code>、<code>resend</code> 等）。</li></ul></li></ol><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><strong>游戏开发</strong>：MOBA、FPS 等对延迟敏感的游戏。</li><li><strong>实时通信</strong>：音视频流、直播、视频会议。</li><li><strong>物联网（IoT）</strong>：弱网环境下的设备间通信。</li><li><strong>P2P 网络</strong>：需要高效可靠传输的分布式系统。</li></ul><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>在相同带宽下，KCP 的延迟通常比 TCP 低 30%-40%，尤其在网络波动较大时表现更优。例如，在 10% 丢包率下，KCP 的吞吐量仍能接近理论最大值。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li><strong>集成源码</strong>：直接包含 <code>ikcp.h</code> 和 <code>ikcp.c</code> 到项目中。</li><li><strong>配置参数</strong>：根据场景调整模式与参数（如 <code>ikcp_nodelay</code> 开启极速模式）。</li><li><strong>绑定 UDP Socket</strong>：通过回调函数与 UDP 结合，实现数据收发。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开源项目收集&quot;&gt;&lt;a href=&quot;#开源项目收集&quot; class=&quot;headerlink&quot; title=&quot;开源项目收集&quot;&gt;&lt;/a&gt;开源项目收集&lt;/h1&gt;&lt;p&gt;本文档收集一些有意思的开源项目：&lt;/p&gt;
&lt;h2 id=&quot;linenoise&quot;&gt;&lt;a href=&quot;#line</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hijack_mac</title>
    <link href="https://dailynobug.github.io/2024/06/17/hijack_mac/"/>
    <id>https://dailynobug.github.io/2024/06/17/hijack_mac/</id>
    <published>2024-06-17T01:17:51.000Z</published>
    <updated>2025-04-14T09:05:40.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mac地址欺骗"><a href="#mac地址欺骗" class="headerlink" title="mac地址欺骗"></a>mac地址欺骗</h1><h2 id="系统调用劫持"><a href="#系统调用劫持" class="headerlink" title="系统调用劫持"></a>系统调用劫持</h2><p>通过劫持系统调用，可以拦截和修改应用程序请求的硬件信息，如 MAC 地址。</p><h4 id="使用-LD-PRELOAD-劫持-getifaddrs-系统调用"><a href="#使用-LD-PRELOAD-劫持-getifaddrs-系统调用" class="headerlink" title="使用 LD_PRELOAD 劫持 getifaddrs 系统调用"></a>使用 <code>LD_PRELOAD</code> 劫持 <code>getifaddrs</code> 系统调用</h4><ol><li><p><strong>编写劫持库</strong>：</p><ul><li>创建一个共享库，劫持 <code>getifaddrs</code> 系统调用以返回伪造的 MAC 地址。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ifaddrs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netpacket/packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getifaddrs</span><span class="params">(struct ifaddrs **ifap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取原始的 getifaddrs 函数</span></span><br><span class="line">    <span class="keyword">int</span> (*original_getifaddrs)(struct ifaddrs **);</span><br><span class="line">    original_getifaddrs = dlsym(RTLD_NEXT, <span class="string">"getifaddrs"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始 getifaddrs 函数</span></span><br><span class="line">    <span class="keyword">int</span> result = original_getifaddrs(ifap);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印调试信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"getifaddrs called\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历接口列表并修改 MAC 地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ifaddrs</span> *<span class="title">ifa</span> = *<span class="title">ifap</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (ifa) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ifa-&gt;ifa_addr &amp;&amp; ifa-&gt;ifa_addr-&gt;sa_family == AF_PACKET) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_ll</span> *<span class="title">s</span> = (<span class="title">struct</span> <span class="title">sockaddr_ll</span> *)<span class="title">ifa</span>-&gt;<span class="title">ifa_addr</span>;</span></span><br><span class="line">            <span class="comment">// 修改 MAC 地址</span></span><br><span class="line">            s-&gt;sll_addr[<span class="number">0</span>] = <span class="number">0x02</span>;</span><br><span class="line">            s-&gt;sll_addr[<span class="number">1</span>] = <span class="number">0x42</span>;</span><br><span class="line">            s-&gt;sll_addr[<span class="number">2</span>] = <span class="number">0xac</span>;</span><br><span class="line">            s-&gt;sll_addr[<span class="number">3</span>] = <span class="number">0x11</span>;</span><br><span class="line">            s-&gt;sll_addr[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">            s-&gt;sll_addr[<span class="number">5</span>] = <span class="number">0x02</span>;</span><br><span class="line">            <span class="comment">// 打印调试信息</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Modified MAC address for interface %s\n"</span>, ifa-&gt;ifa_name);</span><br><span class="line">        &#125;</span><br><span class="line">        ifa = ifa-&gt;ifa_next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编译共享库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC -o libspoof_mac.so spoof_mac.c -ldl</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>LD_PRELOAD</code> 运行目标程序</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=./libspoof_mac.so ./target_program</span><br></pre></td></tr></table></figure></li></ol><p>如果出现mac地址欺骗未成功，可以尝试劫持其他相关系统调用，例如 <code>ioctl</code></p><p><code>SIOCGIFHWADDR</code> 是一个特定的 <code>ioctl</code> 请求码，用于获取网络接口的硬件地址（MAC 地址）。<code>ioctl</code> 是一个通用的输入&#x2F;输出控制接口，可以对设备文件进行各种操作，而 <code>SIOCGIFHWADDR</code> 则专门用于网络设备。</p><h3 id="SIOCGIFHWADDR-的使用"><a href="#SIOCGIFHWADDR-的使用" class="headerlink" title="SIOCGIFHWADDR 的使用"></a><code>SIOCGIFHWADDR</code> 的使用</h3><p>当一个程序想要获取某个网络接口的 MAC 地址时，会使用 <code>ioctl</code> 系统调用并传递 <code>SIOCGIFHWADDR</code> 请求码。这个请求码指示内核返回指定网络接口的硬件地址。</p><h3 id="请求的结构"><a href="#请求的结构" class="headerlink" title="请求的结构"></a>请求的结构</h3><p>在使用 <code>SIOCGIFHWADDR</code> 请求时，通常需要一个 <code>struct ifreq</code> 结构体作为参数。该结构体定义在 <code>&lt;net/if.h&gt;</code> 头文件中，主要包含网络接口的名称和相关信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netpacket/packet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义劫持的 ioctl 函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">unsigned</span> <span class="keyword">long</span> request, ...)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*original_ioctl)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, ...)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!original_ioctl) &#123;</span><br><span class="line">        original_ioctl = dlsym(RTLD_NEXT, <span class="string">"ioctl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request == SIOCGIFHWADDR) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ifreq</span> *<span class="title">ifr</span> = <span class="title">va_arg</span>(<span class="title">args</span>, <span class="title">struct</span> <span class="title">ifreq</span> *);</span></span><br><span class="line">        ret = original_ioctl(fd, request, ifr);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 打印调试信息</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Intercepted SIOCGIFHWADDR for interface: %s\n"</span>, ifr-&gt;ifr_name);</span><br><span class="line">            <span class="comment">// 修改 MAC 地址</span></span><br><span class="line">            ifr-&gt;ifr_hwaddr.sa_data[<span class="number">0</span>] = <span class="number">0x02</span>;</span><br><span class="line">            ifr-&gt;ifr_hwaddr.sa_data[<span class="number">1</span>] = <span class="number">0x42</span>;</span><br><span class="line">            ifr-&gt;ifr_hwaddr.sa_data[<span class="number">2</span>] = <span class="number">0xac</span>;</span><br><span class="line">            ifr-&gt;ifr_hwaddr.sa_data[<span class="number">3</span>] = <span class="number">0x11</span>;</span><br><span class="line">            ifr-&gt;ifr_hwaddr.sa_data[<span class="number">4</span>] = <span class="number">0x00</span>;</span><br><span class="line">            ifr-&gt;ifr_hwaddr.sa_data[<span class="number">5</span>] = <span class="number">0x02</span>;</span><br><span class="line">            <span class="comment">// 打印调试信息</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Modified MAC address for interface %s\n"</span>, ifr-&gt;ifr_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = original_ioctl(fd, request, va_arg(args, <span class="keyword">void</span> *));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mac地址欺骗&quot;&gt;&lt;a href=&quot;#mac地址欺骗&quot; class=&quot;headerlink&quot; title=&quot;mac地址欺骗&quot;&gt;&lt;/a&gt;mac地址欺骗&lt;/h1&gt;&lt;h2 id=&quot;系统调用劫持&quot;&gt;&lt;a href=&quot;#系统调用劫持&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>泰山派调试常用命令</title>
    <link href="https://dailynobug.github.io/2024/06/17/%E6%B3%B0%E5%B1%B1%E6%B4%BE%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://dailynobug.github.io/2024/06/17/%E6%B3%B0%E5%B1%B1%E6%B4%BE%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-06-17T01:17:51.000Z</published>
    <updated>2025-04-14T09:05:40.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泰山派调试常用命令"><a href="#泰山派调试常用命令" class="headerlink" title="泰山派调试常用命令"></a>泰山派调试常用命令</h1><h2 id="ubuntu下使用命令行连接wifi"><a href="#ubuntu下使用命令行连接wifi" class="headerlink" title="ubuntu下使用命令行连接wifi"></a>ubuntu下使用命令行连接wifi</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo iwlist scan</span><br><span class="line">nmcli device wifi list</span><br><span class="line">nmcli device wifi connect &#123;ESSID&#125; password &#123;PASSWORD&#125;</span><br><span class="line">nmcli device wifi connect 404_2.4g password &quot;@404@404&quot; </span><br><span class="line">nmcli device wifi connect &quot;404_5g&quot; password &quot;@404@404@404&quot; ifname wlan0</span><br><span class="line">make modules_install INSTALL_MOD_PATH&#x3D;&lt;rootfs_path&gt;</span><br></pre></td></tr></table></figure><p><img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250305184418243.png" alt="image-20250305184418243"></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250305184418243.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250305184435807.png" alt="image-20250305184435807" title="">                </div>                <div class="image-caption">image-20250305184435807</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://tuchuang-e682.obs.cn-north-1.myhuaweicloud.com/image-20250305184444185.png" alt="image-20250305184444185" title="">                </div>                <div class="image-caption">image-20250305184444185</div>            </figure><h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> v4l2-ctl --list-devices</span><br><span class="line">v4l2-ctl --list-formats-ext --device=/dev/video0</span><br><span class="line">v4l2-ctl -d /dev/video0 -L</span><br><span class="line">v4l2-ctl --set-ctrl analogue_gain=80</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v4l2-ctl --verbose -d /dev/video0 --set-fmt-video=width=1920,height=1080,pixelformat='UYVY' --stream-mmap=20 --set-selection=target=crop,flags=0,top=0,left=0,width=1920,height=1080 --set-ctrl analogue_gain=80  --stream-to=/tmp/out.yuv</span><br><span class="line"></span><br><span class="line">v4l2-ctl --verbose -d /dev/video1 --set-fmt-video=width=1920,height=1080,pixelformat='UYVY' --stream-mmap=20 --stream-to=/tmp/out.yuv</span><br><span class="line"></span><br><span class="line">ffmpeg -f v4l2 -input_format nv12 -video_size 1920x1080 -i /dev/video0 -c:v libx264 -preset ultrafast output.mp4</span><br><span class="line"></span><br><span class="line">ffmpeg -f v4l2 -i /dev/video0 -pixel_format yuv422p -framerate 15 -video_size 800x600 -c:v copy -f mpegts udp://@:1234</span><br><span class="line"></span><br><span class="line">ffmpeg -f v4l2 -input_format nv12 -video_size 1920x1080 -i /dev/video8 -t 10 output.yuv</span><br><span class="line"></span><br><span class="line">ffmpeg -f rawvideo -pixel_format yuv422p -video_size 3840x2160 -framerate 24 -i out.yuv -c:v libx264 output.mp4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scp lsc@192.168.115.129:/home/lsc/project/Release/kernel/boot.img ./</span><br></pre></td></tr></table></figure><h2 id="硬件编码测试"><a href="#硬件编码测试" class="headerlink" title="硬件编码测试"></a>硬件编码测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 配置 ---</span></span><br><span class="line">TARGET_IP = <span class="string">"192.168.3.71"</span>  <span class="comment"># 接收端电脑的 IP 地址 (运行 OBS 的电脑)</span></span><br><span class="line">TARGET_PORT = <span class="number">1234</span>          <span class="comment"># 目标 UDP 端口 (与 OBS 设置一致)</span></span><br><span class="line">CAMERA_INDEX = <span class="number">0</span>            <span class="comment"># 摄像头的索引 (通常是 0 或 1)</span></span><br><span class="line">JPEG_QUALITY = <span class="number">70</span>           <span class="comment"># JPEG 编码质量 (0-100, 越高画质越好但数据量越大)</span></span><br><span class="line">SEND_RESOLUTION = (<span class="number">640</span>, <span class="number">480</span>) <span class="comment"># 发送的分辨率 (宽, 高)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># --- 初始化 ---</span></span><br><span class="line"><span class="comment"># 创建 UDP socket</span></span><br><span class="line">udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开摄像头</span></span><br><span class="line">cap = cv2.VideoCapture(CAMERA_INDEX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    print(<span class="string">f"错误：无法打开摄像头索引 <span class="subst">&#123;CAMERA_INDEX&#125;</span>"</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置摄像头分辨率 (可选, 尝试设置)</span></span><br><span class="line"><span class="comment"># cap.set(cv2.CAP_PROP_FRAME_WIDTH, SEND_RESOLUTION[0])</span></span><br><span class="line"><span class="comment"># cap.set(cv2.CAP_PROP_FRAME_HEIGHT, SEND_RESOLUTION[1])</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">f"摄像头已打开。将推流到 UDP <span class="subst">&#123;TARGET_IP&#125;</span>:<span class="subst">&#123;TARGET_PORT&#125;</span>"</span>)</span><br><span class="line">print(<span class="string">f"发送分辨率: <span class="subst">&#123;SEND_RESOLUTION&#125;</span>, JPEG 质量: <span class="subst">&#123;JPEG_QUALITY&#125;</span>"</span>)</span><br><span class="line">print(<span class="string">"按 Ctrl+C 停止推流。"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 读取一帧</span></span><br><span class="line">        ret, frame = cap.read()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">            print(<span class="string">"错误：无法读取摄像头帧。"</span>)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>) <span class="comment"># 等待一下再试</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 调整帧大小</span></span><br><span class="line">        frame_resized = cv2.resize(frame, SEND_RESOLUTION)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将帧编码为 JPEG</span></span><br><span class="line">        encode_param = [int(cv2.IMWRITE_JPEG_QUALITY), JPEG_QUALITY]</span><br><span class="line">        result, encoded_frame = cv2.imencode(<span class="string">'.jpg'</span>, frame_resized, encode_param)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> result:</span><br><span class="line">            print(<span class="string">"错误：JPEG 编码失败。"</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将编码后的数据转换为字节</span></span><br><span class="line">        data = encoded_frame.tobytes()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送数据</span></span><br><span class="line">        <span class="comment"># UDP 对于数据包大小有限制 (通常 &lt; 65507 字节)</span></span><br><span class="line">        <span class="comment"># 如果编码后的帧太大，可能会发送失败或被截断</span></span><br><span class="line">        <span class="keyword">if</span> len(data) &gt; <span class="number">65000</span>:</span><br><span class="line">            print(<span class="string">f"警告：帧数据过大 (<span class="subst">&#123;len(data)&#125;</span> 字节)，可能无法完整发送。尝试降低分辨率或 JPEG 质量。"</span>)</span><br><span class="line">            <span class="comment"># 可以选择跳过此帧或尝试发送</span></span><br><span class="line">            <span class="comment"># continue # 选择跳过</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            udp_socket.sendto(data, (TARGET_IP, TARGET_PORT))</span><br><span class="line">            <span class="comment"># print(f"Sent frame: &#123;len(data)&#125; bytes") # 取消注释以查看发送日志</span></span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">f"发送错误: <span class="subst">&#123;e&#125;</span>"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>) <span class="comment"># 发送失败时稍作等待</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># (可选) 稍微降低帧率，减轻 CPU 负担和网络拥堵</span></span><br><span class="line">        <span class="comment"># time.sleep(0.01) # 约等于 100 FPS 的延迟，根据需要调整</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    print(<span class="string">"\n停止推流..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 清理资源</span></span><br><span class="line">    print(<span class="string">"正在释放资源..."</span>)</span><br><span class="line">    cap.release()</span><br><span class="line">    udp_socket.close()</span><br><span class="line">    cv2.destroyAllWindows() <span class="comment"># 如果在开发板上有显示窗口的话</span></span><br><span class="line">    print(<span class="string">"资源已释放。"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-&gt; Device Drivers                                                                                                                                                                                    │</span><br><span class="line">  │       -&gt; Multimedia support (MEDIA_SUPPORT [=y])                                                                                                                                                         │</span><br><span class="line">  │         -&gt; Media drivers                                                                                                                                                                                 │</span><br><span class="line">  │ (1)       -&gt; V4L platform devices (V4L_PLATFORM_DRIVERS [=y])</span><br></pre></td></tr></table></figure><p>pip install opencv-python numpy</p><p>sudo apt install -y libgl1</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;泰山派调试常用命令&quot;&gt;&lt;a href=&quot;#泰山派调试常用命令&quot; class=&quot;headerlink&quot; title=&quot;泰山派调试常用命令&quot;&gt;&lt;/a&gt;泰山派调试常用命令&lt;/h1&gt;&lt;h2 id=&quot;ubuntu下使用命令行连接wifi&quot;&gt;&lt;a href=&quot;#ubuntu下</summary>
      
    
    
    
    
  </entry>
  
</feed>
